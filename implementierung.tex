\chapter{Implementierung des SYCL-Backends der Alpaka-Bibliothek}
\label{implementierung}

Mit Ausnahme der in den folgenden Abschnitten aufgeführten Besonderheiten
(Abschnitt~\ref{implementierung:besonderheiten}) bzw.\ Probleme
(Abschnitt~\ref{implementierung:probleme}) konnte die Implementierung des
SYCL-Backends für Alpaka recht einfach durchgeführt werden. Als Vorlage für
dessen Aufbau dienten die bereits vorhandenen Backends, wobei hier besonders
das CUDA-Backend hervorzuheben ist.

\section{Besonderheiten des SYCL-Backends}
\label{implementierung:besonderheiten}

\subsection{Beschleuniger-Auswahl}

TODO

\subsection{Zeiger und \textit{accessors}}
\label{implementierung:besonderheiten:zeiger}

Die Übergabe von Datenfeldern an \gls{device}- und \gls{kernel}-Funktionen
erfolgt in Alpaka über die von C oder älterem C++ bekannten Zeiger. Pro
Datenfeld erhält die Funktion üblicherweise einen Zeiger, z.B. vom Typ
\texttt{float*}, und einen ganzzahligen Parameter (meist vom Typ
\texttt{size\_t}), der die Länge des Speicherbereichs angibt. Der
device"=seitige Zeiger wird über die Funktion \texttt{getPtrNative()} aus einem
Alpaka"=Puffer extrahiert und an den Kernel übergeben.

Diese Vorgehensweise war mit allen bisher in Alpaka vorhandenen Backends
unproblematisch, wenngleich etwas altmodisch. SYCL verlangt als Parameter für
die Kernel"=Funktionen jedoch die eigenen \texttt{accessor}"=Datenstrukturen,
eine Übergabe von Zeigern an den Kernel wird in der Spezifikation explizit
verboten \cite[vgl.][192]{sycl2019}. Zwar gibt die Spezifikation an, dass sich
die \texttt{accessor}"=Typen implizit in reine Zeiger umwandeln lassen
\cite[vgl.][27]{sycl2019}, was jedoch von keiner der verfügbaren
Implementierungen unterstützt wird. Im Rahmen dieser Arbeit wurde dieser Umstand
an das SYCL"=Spezifikationskomitee gemeldet und infolgedessen als Fehler in der
Spezifikation anerkannt, der in zukünftigen Versionen behoben sein wird (siehe
die Diskussion in Anhang~\ref{anhang:diskussion:syclspec:implicitaccessor}).

Innerhalb eines Kernels lassen sich die \texttt{accessor}"=Typen in spezielle
Zeigertypen (\texttt{multi\_ptr}) umwandeln, die wiederum in \glqq reine\grqq\
Zeiger konvertierbar sind. Dadurch lässt sich die geschilderte Problematik in
mehreren Stufen lösen:

Auf der Host"=Seite wird beim Aufruf der Funktion \texttt{getPtrNative()} eine
Datenstruktur angelegt, die den SYCL"=Puffer kapselt und sich aus Sicht des
Programmierers weitestgehend wie ein Zeiger verhält. Daneben enthält diese
Struktur ein spezielles Attribut mit dem Namen
\texttt{is\_alpaka\_sycl\_buffer\_wrapper}. (Der Quelltext dieser Struktur ist
in Anhang~\ref{anhang:source:cpp:bufferwrapper} zu finden.)

Dieses Attribut wird bei der Nutzung des Kernel"=Objekts verwendet, um die
Puffer"=Strukturen von den restlichen Parametern abzugrenzen. Strukturen, die
dieses Attribut besitzen, werden an eine spezielle Funktion weitergereicht, die
den Zusammenhang zwischen SYCL"=Puffer und SYCL"=\texttt{accessor} herstellt.
Alle anderen Datentypen werden unverändert zurückgegeben. Da Techniken der
Template"=Meta"=Programmierung verwendet werden, finden diese Transformationen
zur Compile"=Zeit statt. Der gesamte Vorgang ist in
Quelltext~\ref{implementierung:besonderheiten:zeiger:wrappertrans} dargestellt.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
namespace alpaka {
    namespace kernel {
        namespace sycl {
            namespace detail {
                struct general {};
                struct special : general{};
                template <typename> struct acc_t { using type = int; };

                // spezieller Fall: Puffer-Struktur
                template <typename TDim, typename TBuf,
                    typename acc_t<
                        typename TBuf::is_alpaka_sycl_buffer_wrapper>::type = 0>
                inline auto get_access(cl::sycl::handler& cgh, TBuf buf,
                                       special)
                {
                    return buf.buf.template get_access<
                            cl::sycl::access::mode::read_write,
                            cl::sycl::access::target::global_buffer>(cgh);
                }

                // allgemeiner Fall: kein Puffer
                template <typename TDim, typename TBuf>
                inline auto get_access(cl::sycl::handler& cgh, TBuf buf,
                                       general)
                {
                    return buf;
                }

                template <typename TDim, typename... TArgs, std::size_t... Is>
                constexpr auto bind_buffers(cl::sycl::handler& cgh,
                                            std::tuple<TArgs...> args,
                                            std::index_sequence<Is...>)
                {
                    return std::make_tuple(get_access<TDim>(cgh,
                                                            std::get<Is>(args),
                                                            special{})...);
                }
            }
        }
    }
}
    \end{minted}
    \caption{Umwandlung der Puffer in SYCL"=\texttt{accessor}"=Typen durch
             Template"=Meta"=Programmierung}
    \label{implementierung:besonderheiten:zeiger:wrappertrans}
\end{code}

Der Quelltext~\ref{implementierung:besonderheiten:zeiger:transusage} zeigt die
Nutzung der Template"=Meta"=Funktionen innerhalb der Alpaka"=Kernel"=Struktur:
die in einem \texttt{std::tuple} gespeicherten Kernel"=Parameter werden in ein
SYCL"=kompatibles Format umgewandelt.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
namespace alpaka
{
    namespace kernel
    {
        template <typename TDim, typename TIdx,
                  typename TKernelFnObj, typename... TArgs>
        class TaskKernelSycl
        {
            /* weitere Attribute, Konstruktoren, etc. */

            TKernelFnObj m_kernelFnObj;
            std::tuple<TArgs...> m_args;

        public:
            inline operator()(cl::sycl::handler& cgh)
            {
                // transformiere alle Puffer-Parameter in Accessor-Parameter
                auto accessor_args = sycl::detail::bind_buffers<TDim>(
                            cgh, m_args,
                            std::make_index_sequence<sizeof...(TArgs)>{});

                /* weitere Operationen */
            }
        };
    }
}
    \end{minted}
    \caption{Nutzung der Template"=Meta"=Funktionen zur Umwandlung der
             Puffer"=Wrapper in SYCL"=\texttt{accessor}"=Typen}
    \label{implementierung:besonderheiten:zeiger:transusage}
\end{code}

Innerhalb des Kernels werden die \texttt{accessor}"=Typen (über SYCLs
\texttt{multi\_ptr}) nach einem ähnlichen Prinzip in reine Zeiger transformiert.
Die Template"=Meta"=Funktionen sind in
Quelltext~\ref{implementierung:besonderheiten:zeiger:acctrans} gezeigt, deren
Nutzung in Quelltext~\ref{implementierung:besonderheiten:zeiger:acctransusage}.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
namespace alpaka {
    namespace kernel {
        namespace sycl {
            namespace detail {
                struct general {};
                struct special : general{};
                template <typename> struct acc_t { using type = int; };

                // spezieller Fall: Accessor
                template <typename TAccessor,
                    typename acc_t<decltype(
                        std::declval<TAccessor>().get_pointer())>::type = 0>
                inline auto get_pointer(TAccessor accessor, special)
                {
                    return static_cast<typename TAccessor::value_type*>(
                                                    accessor.get_pointer());
                }

                // allgemeiner Fall: kein Accessor
                template <typename TAccessor>
                inline auto get_pointer(TAccessor accessor, general)
                {
                    return accessor;
                }

                template <typename... TArgs, std::size_t... Is>
                constexpr auto transform(std::tuple<TArgs...> args,
                                         std::index_sequence<Is...>)
                {
                    return std::make_tuple(get_pointer(std::get<Is>(args),
                                                       special{})...);
                }
            }
        }
    }
}
    \end{minted}
    \caption{Umwandlung der Puffer in SYCL"=\texttt{accessor}"=Typen durch
             Template"=Meta"=Programmierung}
    \label{implementierung:besonderheiten:zeiger:acctrans}
\end{code}

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
namespace alpaka
{
    namespace kernel
    {
        template <typename TDim, typename TIdx,
                  typename TKernelFnObj, typename... TArgs>
        class TaskKernelSycl
        {
            /* weitere Attribute, Konstruktoren, etc. */

        public:
            inline operator()(cl::sycl::handler& cgh)
            {
                /* vorherige Operationen */

                cgh.parallel_for<sycl::detail::kernel<TKernelFnObj>>(
                    cl::sycl::nd_range<TDim::value> {
                        global_size, local_size
                    },
                [=](cl::sycl::nd_item<TDim::value> work_item)
                {
                    auto pointer_args = transform(
                                accessor_args,
                                std::make_index_sequence<sizeof...(TArgs)>{});

                    /* weitere Operationen und Alpaka-Kernel-Aufruf */
                }
            }
        };
    }
}
    \end{minted}
    \caption{Nutzung der Template"=Meta"=Funktionen zur Umwandlung der
             \texttt{accessor}"=Typen in Zeiger}
    \label{implementierung:besonderheiten:zeiger:acctransusage}
\end{code}
Letztere werden dann an den vom SYCL"=Kernel aufgerufenen
Alpaka"=Kernel übergeben, sodass der Programmierer in seinem Kernel nur die
reinen Zeiger vorfindet. Dadurch lässt sich das SYCL"=Backend analog zu den
restlichen Implementierungen verwenden.

\subsection{Block-Synchronisierung}
\label{implementierung:besonderheiten:synchronisierung}

\begin{itemize}
    \item Alpaka will überall einen Dimensions-Parameter, nur nicht bei der
          Block-Synchronisierung.
    \item SYCL braucht den Dimensionsparameter bei der Block-Synchronisierung.
    \item Lösung: Erfolgt, funktioniert über Templates.
\end{itemize}

\subsection{Besonderheiten für FPGAs}

TODO

\section{Probleme}\label{implementierung:probleme}

Während der Implementierung traten einige Probleme auf, die sich vornehmlich
auf gravierende konzeptionelle Unterschiede zwischen Alpaka und SYCL
zurückführen lassen. Diese werden in den folgenden Abschnitten näher
beschrieben.

\subsection{Event-System}\label{implementierung:probleme:events}

Alpaka übernimmt viele Konzepte des CUDA-API, darunter auch das Event-System.
Durch CUDA-\textit{events} wird dem Programmierer eine weitere
Synchronisationsmöglichkeit eröffnet. Diese können in einem \textit{stream} vor
oder nach asynchronen Operationen -- wie etwa Kopiervorgängen oder dem Starten
eines Kernels -- einsortiert werden. Der Programmierer kann dann später oder
parallel in einem anderen \textit{stream} abfragen, ob das jeweilige
\textit{event} bereits erreicht wurde und gegebenenfalls darauf warten. Darüber
hinaus ermöglichen \textit{events} ein simples Profiling, da z.B. die Zeitspanne
zwischen verschiedenen \textit{events} gemessen werden kann.

SYCL kennt ebenfalls ein \textit{event}-Konzept, das sich jedoch von CUDAs bzw.
Alpakas System unterscheidet. Auch SYCL-\textit{events} lassen sich für
einfaches Profiling nutzen, ermöglichen dem Programmierer jedoch nicht, eine
weitere SYCL-\textit{queue} (dem Gegenstück zu CUDA-\textit{streams}) auf ein
bestimmtes \textit{event} zu warten.

Dies ist für die Implementierung der Alpaka-\textit{events} ein Problem, da hier
CUDAs Verhalten simuliert wird. Zur Zeit ist der Befehl
\texttt{alpaka::wait::waiterWaitFor()} für die \textit{event}-basierte
Synchronisation in Alpaka nicht implementiert, wenn der \textit{waiter} eine
Alpaka-\textit{queue} ist.

\subsection{Geteilter Speicher}\label{implementierung:probleme:shared}

Einige Plattformen der parallelen Programmierung, wie etwa CUDA und OpenCL,
kennen das Konzept eines Speichers auf Multiprozessor-Ebene, der ungefähr
einem programmierbaren L1-Cache entspricht. Dieser Speicher nennt sich im
CUDA-Umfeld \textit{shared memory}, während er bei OpenCL (und SYCL)
\textit{local memory} heißt. Alpaka übernimmt für dieses Speicherkonzept die
CUDA-Terminologie. \textit{Shared memory} steht allen \textit{threads} auf
der \textit{block}-Ebene zur Verfügung und bietet deutlich schnellere
Zugriffszeiten als der globale Speicher.

Es gibt zwei mögliche Arten, Speicher dieses Typs zu reservieren:
\textit{dynamisch}, das heißt außerhalb des Kernel-Codes und zur Laufzeit, sowie
\textit{statisch}, das heißt innerhalb des Kernel-Codes und mit einer zur
Compile-Zeit feststehenden Größe.

Alpaka stellt für beide Varianten eine Schnittstelle bereit. Für den dynamischen
Fall muss der Programmierer das \textit{type trait}
\texttt{alpaka::kernel::traits::BlockSharedMemDynSizeBytes} auf der Host-Seite
für seine Anwendung implementieren. Innerhalb des Kernels kann er dann über die
Alpaka-Funktion \texttt{alpaka::block::shared::dyn::getMem()} auf den Zeiger
zum so reservierten geteilten Speicher zugreifen. Dieser Fall lässt sich auch
für SYCL implementieren, indem man die in
Abschnitt~\ref{implementierung:besonderheiten:zeiger} vorgestellten
Umwandlungen von \textit{accessor}-Typen in \textit{Zeiger} anwendet.

Für den statischen Fall existiert die Funktion
\texttt{alpaka::block::shared::st::allocVar()}, die innerhalb des Kernels
aufgerufen wird und eine beliebige Variable im geteilten Speicher ablegt. Diese
Funktion kann für SYCL nicht implementiert werden, da die SYCL-Spezifikation
dies (im Gegensatz zu OpenCL) bis auf einen bestimmten Sonderfall
\cite[siehe][Abschnitt 4.8.5.3]{sycl2019} nicht vorsieht.

Diese Einschränkung erklärt sich dadurch, dass SYCL mit dem Anspruch entworfen
wurde, von jedem beliebigen modernen C++-Compiler übersetzt werden zu können,
auch wenn dieser keine Unterstützung für OpenCL- und/oder SYCL-Konzepte mit sich
bringt. In diesem Fall generiert der Compiler wie bei jedem anderen C++-Programm
normalen CPU-Maschinencode. Der Umfang des statischen geteilten Speichers steht
zwar bereits zur Compile-Zeit fest und kann daher schon vor dem Aufruf des
Kernels alloziert werden. Der Zeiger auf diesen Speicherbereich kann durch einen
C++-Compiler ohne SYCL-Unterstützung dem betreffenden Kernel vor dessen
Ausführung jedoch gar nicht zugeordnet werden, da für diese Funktion noch kein
Stapelrahmen existiert. (vgl. die GitHub"=Diskussion mit Mitgliedern des
SYCL"=Spezifikationskomitees im
Anhang~\ref{anhang:diskussionen:syclspec:staticshared})

\subsection{Atomare Funktionen}\label{implementierung:probleme:atomics}

\begin{itemize}
    \item SYCL kann anhand eines rohen Zeigers nicht ableiten, welcher
          \texttt{multi\_ptr}-Typ verwendet werden soll.
    \item \texttt{multi\_ptr} wird für SYCL-Atomics benötigt.
    \item Alpaka gibt uns nur rohe Zeiger.
    \item Lösung: Keine. Im Moment funktionieren Atomics nur für den globalen
          Addressraum. Begründung SYCL-Kommittee einfügen.
\end{itemize}

\subsection{FPGA-Erweiterungen}\label{implementierung:probleme:fpga}

Wie SYCL-FPGA-Erweiterungen nutzen?

\subsection{Zufallszahlen und Zeit}

\begin{itemize}
    \item SYCLs Ökosystem ist noch nicht besonders gut ausgeprägt
    \item es gibt noch keine Funktionen für Zufallszahlen und Zeit
\end{itemize}
