\chapter{Implementierung des SYCL-Backends der Alpaka-Bibliothek}
\label{implementierung}

\section{Alternative Struktur}

\subsection{Implementierung der Acc-Struktur}

\subsection{Implementierung atomarer Funktionen}

\subsection{Implementierung des geteilten Speichers}

\subsection{Implementierung der Block-Synchronisation}

\subsection{Implementierung der Dev-Struktur}

\subsection{Implementierung der Events}

\subsection{Implementierung der Index-Funktionen}

\subsection{Implementierung der TaskKernel-Struktur}

\subsection{Implementierung mathematischer Funktionen}

\subsection{Implementierung der Speicherverwaltung}

\subsection{Implementierung der Pltf-Struktur}

\subsection{Implementierung der Queues}

\subsection{Implementierung der workDiv-Struktur}

\subsection{Implementierung der Zufallszahlen}

\subsection{Implementierung der Zeitfunktionen}

\subsection{Zusammenfassung}

Mit Ausnahme der in den folgenden Abschnitten aufgeführten Besonderheiten
(Abschnitt~\ref{implementierung:besonderheiten}) bzw.\ Probleme
(Abschnitt~\ref{implementierung:probleme}) konnte die Implementierung des
SYCL"=Backends für Alpaka recht einfach durchgeführt werden. Als Vorlage für
dessen Aufbau dienten die bereits vorhandenen Backends, wobei hier besonders
das CUDA"=Backend hervorzuheben ist. Die Abbildung der in Alpaka vorhandenen
Datenstrukturen bzw.\ Funktionen auf SYCL"=Funktionalität ist in
Tabelle~\ref{implementierung:abbildung} dargestellt.

\begin{table}[htb]
    \centering
    \begin{tabulary}{\textwidth}{@{}LLL@{}}
        \toprule
        % Überschrift
        \textbf{Bereich} & \textbf{Alpaka} & \textbf{SYCL} \tabularnewline\midrule
        % 1. Zeile
        \multirow{3}{*}{Attribute} & \texttt{ALPAKA\_FN\_HOST}
            & nicht nötig \tabularnewline
        & \texttt{ALPAKA\_FN\_ACC} & nicht nötig \tabularnewline
        & \texttt{ALPAKA\_FN\_HOST\_ACC} & nicht nötig \tabularnewline\midrule
        % 2. Zeile
        \multirow{3}{*}{Adressräume} &
            \texttt{block::shared::st::allocVar()} &
            siehe Abschnitt~\ref{implementierung:probleme:shared}\tabularnewline
            & \texttt{ALPAKA\_STATIC\_ACC\_MEM\_CONSTANT} &
            siehe Abschnitt~\ref{implementierung:probleme:globalvar}\tabularnewline
            & \texttt{ALPAKA\_STATIC\_ACC\_MEM\_GLOBAL} &
            siehe Abschnitt~\ref{implementierung:probleme:globalvar} \tabularnewline\midrule
        \multirow{4}{*}{Indizes} & \texttt{getIdx<Block, Threads>()} &
            \texttt{nd\_item::get\_local\_id()}\tabularnewline
            & \texttt{getIdx<Grid, Blocks>()} &
            \texttt{nd\_item::get\_group()}\tabularnewline
            & \texttt{getWorkDiv<Block, Threads>()} &
            \texttt{nd\_item::get\_local\_range()}\tabularnewline
            & \texttt{getWorkDiv<Grid, Blocks>()} &
            \texttt{nd\_item::get\_group\_range()}\tabularnewline\midrule
        Typen & \texttt{Vec<TDim, TVal>} & \texttt{nd\_range<TDim>}\tabularnewline\midrule
        \multirow{4}{*}{Devices} & \texttt{reset(device)} &
            siehe Abschnitt~\ref{implementierung:probleme:device}\tabularnewline
            & \texttt{wait(device)} &
            siehe Abschnitt~\ref{implementierung:probleme:device}\tabularnewline
            & \texttt{getDevCount()} & siehe Abschnitt~\ref{implementierung:probleme:device}\tabularnewline
            & \texttt{getAccDevProps()} & \texttt{device::get\_info()}\tabularnewline\midrule
        \multirow{5}{*}{Queues} & \texttt{QueueBlocking} & \texttt{queue}\tabularnewline
            & \texttt{QueueNonBlocking} & \texttt{queue} \tabularnewline
            & \texttt{empty(queue)} & siehe Abschnitt~\ref{implementierung:besonderheiten:queue}\tabularnewline
            & \texttt{wait(queue)} & \texttt{queue::wait\_and\_throw()}\tabularnewline
            & \texttt{wait(queue, event)}& siehe Abschnitt~\ref{implementierung:probleme:events}\tabularnewline\midrule
        \multirow{4}{*}{Events} & \texttt{Event} & \texttt{event}\tabularnewline
            & \texttt{test(event)} & \texttt{event::get\_info()}\tabularnewline
            & \texttt{enqueue(queue, event)} & siehe Abschnitt~\ref{implementierung:probleme:events}\tabularnewline
            & \texttt{wait(event)} & \texttt{event::wait\_and\_throw()}\tabularnewline\midrule
        \multirow{7}{*}{Speicher} & \texttt{alloc()} & \texttt{buffer}\tabularnewline
            & \texttt{copy()} (synchron) & \texttt{handler::copy()}\tabularnewline
            & \texttt{copy()} (asynchron) & \texttt{handler::copy()}\tabularnewline
            & \texttt{set()} (synchron) & \texttt{handler::fill()}\tabularnewline
            & \texttt{set()} (asynchron) & \texttt{handler::fill()}\tabularnewline
            & \texttt{getMemBytes()} & \texttt{device::get\_info()}\tabularnewline
            & \texttt{getFreeMemBytes()} & siehe Abschnitt~\ref{implementierung:probleme:speicher}\tabularnewline\midrule
        \multirow{2}{*}{Kernel} & \texttt{exec(queue, workDiv, kernel, ...)} &
            \texttt{queue.enqueue()}\tabularnewline
            & \texttt{BlockSharedExternMemSizeBytes}
            & siehe Abschnitt~\ref{implementierung:besonderheiten:sharedmem}\tabularnewline\bottomrule
    \end{tabulary}
    \caption{Implementierung der Alpaka"=Funktionalität durch SYCL.}
    \label{implementierung:abbildung}
\end{table}

\section{Besonderheiten des SYCL-Backends}
\label{implementierung:besonderheiten}

Durch die beschriebenen Unterschiede zwischen Alpaka und SYCL wurden
stellenweise kreative Lösungen erforderlich, um Alpakas Funktionalität möglichst
gut abbilden zu können. Diese werden in den folgenden Abschnitten näher
beschrieben.

\subsection{Queue- und Event-Verwaltung}\label{implementierung:besonderheiten:queue}



\subsection{Zeiger und \textit{accessors}}
\label{implementierung:besonderheiten:zeiger}

Die Übergabe von Datenfeldern an \gls{device}- und \gls{kernel}-Funktionen
erfolgt in Alpaka über die von C oder älterem C++ bekannten Zeiger. Pro
Datenfeld erhält die Funktion üblicherweise einen Zeiger, z.B. vom Typ
\texttt{float*}, und einen ganzzahligen Parameter (meist vom Typ
\texttt{size\_t}), der die Länge des Speicherbereichs angibt. Der
device"=seitige Zeiger wird über die Funktion \texttt{getPtrNative()} aus einem
Alpaka"=Puffer extrahiert und an den Kernel übergeben.

Diese Vorgehensweise war mit allen bisher in Alpaka vorhandenen Backends
unproblematisch, wenngleich etwas altmodisch. SYCL verlangt als Parameter für
die Kernel"=Funktionen jedoch die eigenen \texttt{accessor}"=Datenstrukturen,
eine Übergabe von Zeigern an den Kernel wird in der Spezifikation explizit
verboten \cite[vgl.][192]{sycl2019}. Zwar gibt die Spezifikation an, dass sich
die \texttt{accessor}"=Typen implizit in reine Zeiger umwandeln lassen
\cite[vgl.][27]{sycl2019}, was jedoch von keiner der verfügbaren
Implementierungen unterstützt wird. Im Rahmen dieser Arbeit wurde dieser Umstand
an das SYCL"=Spezifikationskomitee gemeldet und infolgedessen als Fehler in der
Spezifikation anerkannt, der in zukünftigen Versionen behoben sein wird (siehe
die Diskussion in Anhang~\ref{anhang:diskussion:syclspec:implicitaccessor}).

Innerhalb eines Kernels lassen sich die \texttt{accessor}"=Typen in spezielle
Zeigertypen (\texttt{multi\_ptr}) umwandeln, die wiederum in \glqq reine\grqq\
Zeiger konvertierbar sind. Dadurch lässt sich die geschilderte Problematik in
mehreren Stufen lösen:

Auf der Host"=Seite wird beim Aufruf der Funktion \texttt{getPtrNative()} eine
Datenstruktur angelegt, die den SYCL"=Puffer kapselt und sich aus Sicht des
Programmierers weitestgehend wie ein Zeiger verhält. Daneben enthält diese
Struktur ein spezielles Attribut mit dem Namen
\texttt{is\_alpaka\_sycl\_buffer\_wrapper}. (Der Quelltext dieser Struktur ist
in Anhang~\ref{anhang:source:cpp:bufferwrapper} zu finden.)

Dieses Attribut wird bei der Nutzung des Kernel"=Objekts verwendet, um die
Puffer"=Strukturen von den restlichen Parametern abzugrenzen. Strukturen, die
dieses Attribut besitzen, werden an eine spezielle Funktion weitergereicht, die
den Zusammenhang zwischen SYCL"=Puffer und SYCL"=\texttt{accessor} herstellt.
Alle anderen Datentypen werden unverändert zurückgegeben. Da Techniken der
Template"=Meta"=Programmierung verwendet werden, finden diese Transformationen
zur Compile"=Zeit statt. Der gesamte Vorgang ist in
Quelltext~\ref{implementierung:besonderheiten:zeiger:wrappertrans} dargestellt.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
namespace alpaka {
    namespace kernel {
        namespace sycl {
            namespace detail {
                struct general {};
                struct special : general{};
                template <typename> struct acc_t { using type = int; };

                // spezieller Fall: Puffer-Struktur
                template <typename TDim, typename TBuf,
                    typename acc_t<
                        typename TBuf::is_alpaka_sycl_buffer_wrapper>::type = 0>
                inline auto get_access(cl::sycl::handler& cgh, TBuf buf,
                                       special)
                {
                    return buf.buf.template get_access<
                            cl::sycl::access::mode::read_write,
                            cl::sycl::access::target::global_buffer>(cgh);
                }

                // allgemeiner Fall: kein Puffer
                template <typename TDim, typename TBuf>
                inline auto get_access(cl::sycl::handler& cgh, TBuf buf,
                                       general)
                {
                    return buf;
                }

                template <typename TDim, typename... TArgs, std::size_t... Is>
                constexpr auto bind_buffers(cl::sycl::handler& cgh,
                                            std::tuple<TArgs...> args,
                                            std::index_sequence<Is...>)
                {
                    return std::make_tuple(get_access<TDim>(cgh,
                                                            std::get<Is>(args),
                                                            special{})...);
                }
            }
        }
    }
}
    \end{minted}
    \caption{Umwandlung der Puffer in SYCL"=\texttt{accessor}"=Typen durch
             Template"=Meta"=Programmierung}
    \label{implementierung:besonderheiten:zeiger:wrappertrans}
\end{code}

Der Quelltext~\ref{implementierung:besonderheiten:zeiger:transusage} zeigt die
Nutzung der Template"=Meta"=Funktionen innerhalb der Alpaka"=Kernel"=Struktur:
die in einem \texttt{std::tuple} gespeicherten Kernel"=Parameter werden in ein
SYCL"=kompatibles Format umgewandelt.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
namespace alpaka
{
    namespace kernel
    {
        template <typename TDim, typename TIdx,
                  typename TKernelFnObj, typename... TArgs>
        class TaskKernelSycl
        {
            /* weitere Attribute, Konstruktoren, etc. */

            TKernelFnObj m_kernelFnObj;
            std::tuple<TArgs...> m_args;

        public:
            inline operator()(cl::sycl::handler& cgh)
            {
                // transformiere alle Puffer-Parameter in Accessor-Parameter
                auto accessor_args = sycl::detail::bind_buffers<TDim>(
                            cgh, m_args,
                            std::make_index_sequence<sizeof...(TArgs)>{});

                /* weitere Operationen */
            }
        };
    }
}
    \end{minted}
    \caption{Nutzung der Template"=Meta"=Funktionen zur Umwandlung der
             Puffer"=Wrapper in SYCL"=\texttt{accessor}"=Typen}
    \label{implementierung:besonderheiten:zeiger:transusage}
\end{code}

Innerhalb des Kernels werden die \texttt{accessor}"=Typen (über SYCLs
\texttt{multi\_ptr}) nach einem ähnlichen Prinzip in reine Zeiger transformiert.
Die Template"=Meta"=Funktionen sind in
Quelltext~\ref{implementierung:besonderheiten:zeiger:acctrans} gezeigt, deren
Nutzung in Quelltext~\ref{implementierung:besonderheiten:zeiger:acctransusage}.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
namespace alpaka {
    namespace kernel {
        namespace sycl {
            namespace detail {
                struct general {};
                struct special : general{};
                template <typename> struct acc_t { using type = int; };

                // spezieller Fall: Accessor
                template <typename TAccessor,
                    typename acc_t<decltype(
                        std::declval<TAccessor>().get_pointer())>::type = 0>
                inline auto get_pointer(TAccessor accessor, special)
                {
                    return static_cast<typename TAccessor::value_type*>(
                                                    accessor.get_pointer());
                }

                // allgemeiner Fall: kein Accessor
                template <typename TAccessor>
                inline auto get_pointer(TAccessor accessor, general)
                {
                    return accessor;
                }

                template <typename... TArgs, std::size_t... Is>
                constexpr auto transform(std::tuple<TArgs...> args,
                                         std::index_sequence<Is...>)
                {
                    return std::make_tuple(get_pointer(std::get<Is>(args),
                                                       special{})...);
                }
            }
        }
    }
}
    \end{minted}
    \caption{Umwandlung der Puffer in SYCL"=\texttt{accessor}"=Typen durch
             Template"=Meta"=Programmierung}
    \label{implementierung:besonderheiten:zeiger:acctrans}
\end{code}

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
namespace alpaka
{
    namespace kernel
    {
        template <typename TDim, typename TIdx,
                  typename TKernelFnObj, typename... TArgs>
        class TaskKernelSycl
        {
            /* weitere Attribute, Konstruktoren, etc. */

        public:
            inline operator()(cl::sycl::handler& cgh)
            {
                /* vorherige Operationen */

                cgh.parallel_for<sycl::detail::kernel<TKernelFnObj>>(
                    cl::sycl::nd_range<TDim::value> {
                        global_size, local_size
                    },
                [=](cl::sycl::nd_item<TDim::value> work_item)
                {
                    auto pointer_args = transform(
                                accessor_args,
                                std::make_index_sequence<sizeof...(TArgs)>{});

                    /* weitere Operationen und Alpaka-Kernel-Aufruf */
                }
            }
        };
    }
}
    \end{minted}
    \caption{Nutzung der Template"=Meta"=Funktionen zur Umwandlung der
             \texttt{accessor}"=Typen in Zeiger}
    \label{implementierung:besonderheiten:zeiger:acctransusage}
\end{code}
Letztere werden dann an den vom SYCL"=Kernel aufgerufenen
Alpaka"=Kernel übergeben, sodass der Programmierer in seinem Kernel nur die
reinen Zeiger vorfindet. Dadurch lässt sich das SYCL"=Backend analog zu den
restlichen Implementierungen verwenden.

\subsection{Dynamischer geteilter Speicher}
\label{implementierung:besonderheiten:sharedmem}

\section{Probleme}\label{implementierung:probleme}

Während der Implementierung traten einige Probleme auf, die sich vornehmlich
auf gravierende konzeptionelle Unterschiede zwischen Alpaka und SYCL
zurückführen lassen. Diese werden in den folgenden Abschnitten näher
beschrieben.

\subsection{Globale Variablen}\label{implementierung:probleme:globalvar}

Die Makros \texttt{ALPAKA\_STATIC\_ACC\_MEM\_GLOBAL} und
\texttt{ALPAKA\_STATIC\_ACC\_MEM\_CONSTANT} werden von Alpaka zur Verfügung
gestellt, um globale Variablen direkt im globalen bzw. konstanten
\textit{Device}"=Speicher anlegen zu können. Diese dienen vornehmlich der
Abstraktion der CUDA"=Schlüsselwörter texttt{\_\_device\_\_} und
\texttt{\_\_constant\_\_}, die dieselbe Funktion erfüllen. Diese Funktionalität
wurde für die restlichen Alpaka"=Backends bisher nicht benötigt. Im Zusammenhang
mit SYCL kommt es hier jedoch zu Problemen.

Zwar ist das Anlegen globaler \textit{device}"=seitiger Variablen auch in SYCL
möglich, erfordert hier aber den Weg über Puffer und \textit{accessors}. Die
C++"=Makro"=Mächtigkeit reicht allerdings nicht aus, um aus einer
Variablendeklaration

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
ALPAKA_STATIC_ACC_MEM_GLOBAL int x;
    \end{minted}
\end{code}

eine Transformation in einen SYCL"=Puffer sowie einen zugehörigen
\textit{accessor} durchzuführen:

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
cl::sycl::buffer<int, 1>{cl::sycl::range<1>{1}} x_buf;
// im Kernel
auto acc = x_buf.get_access</* ... */>(cgh);
    \end{minted}
\end{code}

Daher konnte die Implementierung der obigen Makros für das SYCL"=Backend nicht
durchgeführt werden.

\subsection{Device-Verwaltung}\label{implementierung:probleme:device}

\subsection{Speicherverwaltung}\label{implementierung:probleme:speicher}

\subsection{Event-System}\label{implementierung:probleme:events}

Alpaka übernimmt viele Konzepte des CUDA-API, darunter auch das Event-System.
Durch CUDA-\textit{events} wird dem Programmierer eine weitere
Synchronisationsmöglichkeit eröffnet. Diese können in einem \textit{stream} vor
oder nach asynchronen Operationen -- wie etwa Kopiervorgängen oder dem Starten
eines Kernels -- einsortiert werden. Der Programmierer kann dann später oder
parallel in einem anderen \textit{stream} abfragen, ob das jeweilige
\textit{event} bereits erreicht wurde und gegebenenfalls darauf warten. Darüber
hinaus ermöglichen \textit{events} ein simples Profiling, da z.B. die Zeitspanne
zwischen verschiedenen \textit{events} gemessen werden kann.

SYCL kennt ebenfalls ein \textit{event}-Konzept, das sich jedoch von CUDAs bzw.
Alpakas System unterscheidet. Auch SYCL-\textit{events} lassen sich für
einfaches Profiling nutzen, ermöglichen dem Programmierer jedoch nicht, eine
weitere SYCL-\textit{queue} (dem Gegenstück zu CUDA-\textit{streams}) auf ein
bestimmtes \textit{event} zu warten.

Dies ist für die Implementierung der Alpaka-\textit{events} ein Problem, da hier
CUDAs Verhalten simuliert wird. Zur Zeit ist der Befehl
\texttt{alpaka::wait::waiterWaitFor()} für die \textit{event}-basierte
Synchronisation in Alpaka nicht implementiert, wenn der \textit{waiter} eine
Alpaka-\textit{queue} ist.

\subsection{Statischer geteilter Speicher}
\label{implementierung:probleme:shared}

Einige Plattformen der parallelen Programmierung, wie etwa CUDA und OpenCL,
kennen das Konzept eines Speichers auf Multiprozessor-Ebene, der ungefähr
einem programmierbaren L1-Cache entspricht. Dieser Speicher nennt sich im
CUDA-Umfeld \textit{shared memory}, während er bei OpenCL (und SYCL)
\textit{local memory} heißt. Alpaka übernimmt für dieses Speicherkonzept die
CUDA-Terminologie. \textit{Shared memory} steht allen \textit{threads} auf
der \textit{block}-Ebene zur Verfügung und bietet deutlich schnellere
Zugriffszeiten als der globale Speicher.

Es gibt zwei mögliche Arten, Speicher dieses Typs zu reservieren:
\textit{dynamisch}, das heißt außerhalb des Kernel-Codes und zur Laufzeit, sowie
\textit{statisch}, das heißt innerhalb des Kernel-Codes und mit einer zur
Compile-Zeit feststehenden Größe.

Alpaka stellt für beide Varianten eine Schnittstelle bereit. Für den dynamischen
Fall muss der Programmierer das \textit{type trait}
\texttt{alpaka::kernel::traits::BlockSharedMemDynSizeBytes} auf der Host-Seite
für seine Anwendung implementieren. Innerhalb des Kernels kann er dann über die
Alpaka-Funktion \texttt{alpaka::block::shared::dyn::getMem()} auf den Zeiger
zum so reservierten geteilten Speicher zugreifen. Dieser Fall lässt sich auch
für SYCL implementieren, indem man die in
Abschnitt~\ref{implementierung:besonderheiten:zeiger} vorgestellten
Umwandlungen von \textit{accessor}-Typen in \textit{Zeiger} anwendet.

Für den statischen Fall existiert die Funktion
\texttt{alpaka::block::shared::st::allocVar()}, die innerhalb des Kernels
aufgerufen wird und eine beliebige Variable im geteilten Speicher ablegt. Diese
Funktion kann für SYCL nicht implementiert werden, da die SYCL-Spezifikation
dies (im Gegensatz zu OpenCL) bis auf einen bestimmten Sonderfall
\cite[siehe][Abschnitt 4.8.5.3]{sycl2019} nicht vorsieht.

Diese Einschränkung erklärt sich dadurch, dass SYCL mit dem Anspruch entworfen
wurde, von jedem beliebigen modernen C++-Compiler übersetzt werden zu können,
auch wenn dieser keine Unterstützung für OpenCL- und/oder SYCL-Konzepte mit sich
bringt. In diesem Fall generiert der Compiler wie bei jedem anderen C++-Programm
normalen CPU-Maschinencode. Der Umfang des statischen geteilten Speichers steht
zwar bereits zur Compile-Zeit fest und kann daher schon vor dem Aufruf des
Kernels alloziert werden. Der Zeiger auf diesen Speicherbereich kann durch einen
C++-Compiler ohne SYCL-Unterstützung dem betreffenden Kernel vor dessen
Ausführung jedoch gar nicht zugeordnet werden, da für diese Funktion noch kein
Stapelrahmen existiert. Vom SYCL"=Spezifikationskomitee wird jedoch zur Zeit
untersucht, inwieweit diese Funktionalität trotzdem verfügbar gemacht werden
kann (vgl. die GitHub"=Diskussion mit Mitgliedern des
SYCL"=Spezifikationskomitees im
Anhang~\ref{anhang:diskussionen:syclspec:staticshared}).

\subsection{Atomare Funktionen}\label{implementierung:probleme:atomics}

Durch die Nutzung von Zeigern kommt es zu gravierenden Problemen mit atomaren
Funktionen. SYCLs vorhandene atomare Funktionen erfordern zwingend die Nutzung
der \texttt{multi\_ptr}"=Strukturen, welche wiederum mit ihrem Adressraum
verknüpft werden -- das heißt, sie werden eindeutig dem globalen, lokalen oder
konstanten Adressraum zugeordnet. Da in Alpaka jedoch nur C"=Zeiger
verwendet werden, ist diese Information innerhalb der Alpaka"=Hierarchie nicht
mehr vorhanden. Dadurch kann in der Implementierungsschicht der
Alpaka"=Funktionen kein lokaler \texttt{multi\_ptr} angelegt werden.

Erschwerend kommt hinzu, dass auch die vorhandenen SYCL"=Compiler nicht in der
Lage sind, den Adressraum selbst zu ermitteln. Diese Problematik wurde im Rahmen
dem SYCL"=Spezifikationskomitee im Rahmen der Arbeit gemeldet, bisher gibt es
jedoch noch keinen Lösungsansatz (vgl. die GitHub"=Diskussion mit Mitgliedern
des SYCL"=Spezifikationskomitees im
Anhang~\ref{anhang:diskussionen:syclspec:addressspac}).

Zur Zeit wird in der SYCL"=Implementierung der atomaren Funktionen daher
angenommen, dass jeder übergebene Zeiger dem globalen Adressraum angehört --
atomare Funktionen im lokalen oder konstanten Adressraum werden deshalb nicht
unterstützt.

\subsection{FPGA-Erweiterungen}\label{implementierung:probleme:fpga}

Wie in Abschnitt~\ref{sycl:erweiterungen} dargestellt wurde, existieren einige
SYCL"=Erweiterungen für FPGAs, die eine bessere Nutzung dieser Hardware
ermöglichen sollen. Diese sind naturgemäß nicht auf anderen
Hardware"=Plattformen (oder auf FPGAs verschiedener Hersteller) nutzbar. Es
stellt sich daher die Frage, wie diese herstellerabhängigen Erweiterungen
innerhalb der Alpaka"=Bibliothek nutzbar gemacht werden können. Für den
SYCL"=Backend"=Prototypen wurde auf Erweiterungen verzichtet, um die
Hardware"=Unabhängigkeit nicht zu gefährden. Dies ist jedoch kein dauerhaft
wünschenswerter Zustand, da die Erweiterungen ganz erhebliche Performanzgewinne
zur Folge haben können.

\subsection{Zufallszahlen und Zeit}

Da SYCL erst wenige Jahre alt ist, ist das zugehörige Ökosystem noch nicht
sonderlich stark ausgeprägt. So fehlt auch Funktionalität, die auf Seiten des
\textit{Devices} die Generierung von Zufallszahlen oder Zeitmessung erlauben.
Alpaka stellt diese Funktionen jedoch zur Verfügung. Eine Lösung für dieses
Problem konnte im Rahmen dieser Arbeit nicht gefunden werden, diese
Funktionalität fehlt daher für das SYCL"=Backend.
