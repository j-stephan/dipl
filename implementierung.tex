\chapter{Implementierung des SYCL-Backends der Alpaka-Bibliothek}
\label{implementierung}

Die Implementierung des Alpaka"=SYCL"=Backends gestaltete sich in weiten Teilen
recht einfach. Stellenweise erforderte sie umfangreiche \textit{Workarounds},
wenn Alpakas Konzepte nicht direkt auf SYCL"=Funktionalität abzubilden waren.
An anderen Punkten konnte dagegen keine SYCL"=Implementierung durchgeführt
werden, da Alpaka und SYCL zu widersprüchlich waren.

Die folgenden Abschnitte widmen sich jeweils der Implementierung eines
Alpaka"=Konzepts und der damit zusammenhängenden Datenstrukturen. Sofern es bei
einem Konzept zu den beschriebenen Schwierigkeiten kam, sind diese dort
ebenfalls aufgeführt.

Das SYCL"=Backend wurde auf Basis des Alpaka"=Entwicklungszweigs
\texttt{develop} entwickelt und hat dessen Neuentwicklungen im Laufe der Arbeit
regelmäßig übernommen. Es basiert auf dem Stand vom 23.\ September 2019
(Commit \#82d3294). Alpaka unterstützt mit seinem Interface noch den
C++11"=Standard. Für das Backend selbst wurde jedoch auf C++17 gesetzt, da
dieser Standard von den SYCL"=Implementierungen ComputeCpp, Intel und Xilinx
unterstützt wird und die letzteren beiden C++17 sogar voraussetzen.

\section{\textit{Device}-Verwaltung}
\label{implementierung:device}

Am Anfang jedes Alpaka"=Programms steht die Auswahl des Beschleunigers. In
Alpaka findet diese zur Compile"=Zeit statt. Da der Beschleunigertyp bislang
durch die Auswahl des Backends impliziert wurde (CUDA \textrightarrow{} GPU,
HIP \textrightarrow{} GPU, OpenMP \textrightarrow{} CPU, \ldots), führte dies
nicht zu Problemen.

In SYCL wird diese Wahl erst zur Laufzeit durchgeführt. Der Programmierer gibt
zwar einen \texttt{device\_selector} zur Compile"=Zeit an (oder wählt den
in Kapitel~\ref{sycl} beschriebenen umfangreicheren Weg zur
\textit{Device}"=Wahl), dieser wird jedoch erst von der SYCL"=Laufzeitumgebung
verwendet. Der SYCL"=Compiler kennt also noch nicht das zukünftig verwendete
\textit{Device}.

Dies führt zu Schwierigkeiten mit Alpaka. Die Annahme, dass das konkrete
\textit{Device} erst zur Laufzeit bekannt sein könnte, findet sich nicht in
Alpaka. Das auf \textit{type traits} der Template"=Meta"=Programmierung
basierende System zur Auswahl des Beschleunigers stößt hier an seine Grenzen.
Wie im Kapitel~\ref{alpaka} beschrieben wurde, fungiert eine vom Benutzer
gewählte \texttt{Acc}"=Datenstruktur als Template"=Parameter für viele
abstrakte Alpaka"=Klassen, die dadurch einen konkreten Code"=Pfad wählen können.
Die \texttt{Acc}"=Datenstrukur selbst wird jedoch nicht auf der
\textit{Host}"=, sondern auf der \textit{Device}"=Seite instanziiert und kann
deshalb keinen SYCL"=\texttt{device\_selector} kapseln.

Nun ließe sich einwenden, dass mehrere spezialisierte
\texttt{Acc}"=Datenstrukturen implementiert werden könnten, die jedes denkbare
SYCL"=\textit{Device} abbilden. Sieht man von der daraus resultierenden
Code"=Duplizierung an vielen Stellen im Backend ab, ist damit jedoch noch nicht
die Frage der wechselseitigen Beziehungen zwischen \texttt{Acc} und anderen
Backend"=Klassen gelöst. Ist z.B. nur ein Alpaka"=Task gegeben, lässt sich der
zugehörige \texttt{Acc} über Alpakas \textit{type traits} ermitteln. Welche der
spezialisierten \texttt{Acc}"=Klassen soll aber gewählt werden, wenn nur ein
Task ohne weitere Informationen gegeben ist?

Die Frage der \textit{Device}"=Wahl ließ sich im Rahmen der Arbeit nicht
befriedigend lösen. Darüber hinaus ist dies kein SYCL"=spezifisches Problem,
da neuere OpenMP"=Standards ebenfalls mehrere Beschleunigertypen kennen. Hier
ist eine Alpaka"=weite Lösung erforderlich. Denkbar wäre beispielsweise nicht
nur die Angabe der gewünschten Backend"=Plattform (z.B. \texttt{Sycl}), sondern
auch die zusätzliche Wahl eines konkreten \textit{Devices} zur Compile"=Zeit
(z.B. \texttt{XilinxFpga}) anstelle der \texttt{Acc}"=Datenstruktur. Sowohl das
Backend als auch das gewählte \textit{Device} sollten dabei ausschließlich auf
der \textit{Host}"=Seite instanziiert werden, da es ansonsten wieder zu den
Problemen kommt, die momentan bei der Verwendung der \texttt{Acc}"=Struktur
auftreten.

Die Angabe generischer \textit{Devices} zur Compile"=Zeit und die Auswahl eines
konkreten \textit{Devices} zur Laufzeit dürfte nicht ausreichen, da es z.B.
zwischen FPGAs verschiedener Hersteller durch unterschiedliche Erweiterungen
auch zu herstellerabhängigen Code"=Pfaden kommen kann.

Der SYCL"=Backend"=Prototyp erfordert aus den genannten Gründen eine manuelle
Auswahl des gewünschten \textit{device\_selectors} innerhalb der
\texttt{Pltf}"=Schicht.

Wünscht der Nutzer das SYCL"=Backend, steht ihm die Klasse \texttt{AccSycl} zur
Verfügung. Diese dient als Parameter für die Klasse \texttt{PltfSycl}, welche
zur Laufzeit die \textit{Device}"=Auswahl trifft. \texttt{PltfSycl} erzeugt
dann ein Objekt der Klasse \texttt{DevSycl}, welches das von der
SYCL"=Laufzeitumgebung erzeugte SYCL"=\texttt{device} kapselt und Alpakas
\textit{Device}"=Verwaltungsfunktionen auf die äquivalenten SYCL"=Funktionen
abbildet.

\subsection{Fehlende \textit{Device}"=Informationen}

Alpaka bietet dem Nutzer die Möglichkeit, auf Laufzeit"=Informationen über das
verwendete \textit{Device} zuzugreifen. Darunter fällt auch die Angabe, wie viel
globaler Speicher noch unbelegt ist (\texttt{dev::getFreeMemBytes()}). Da es in
SYCL keine Möglichkeit gibt, diese Information abzufragen, konnte diese Funktion
nicht implementiert werden.

\subsection{Fehlende \textit{Device}"=Funktionen}

In CUDA und deshalb auch in Alpaka gibt es die Möglichkeit, ein \textit{Device}
in seinen Ursprungszustand zurückzusetzen. Alpakas Funktion
\texttt{dev::reset()} unterbricht laufende Kernel und gibt alle Speicherbereiche
frei. 

In SYCL spielt die \texttt{device}"=Struktur eine weitaus weniger wichtige
Rolle als seine CUDA"= und Alpaka"=Äquivalente. Ein Äquivalent zu
\texttt{dev::reset()} existiert deswegen nicht, und die Dokumentation zum
Destruktor der \texttt{device}"=Klasse enthält keine Angaben darüber, wie sich
der Aufruf auf den Zustand des tatsächlichen \textit{Devices} auswirkt
\cite[vgl.][33,41,58]{sycl2019}.

Eine befriedigende Implementierung der \texttt{dev::reset()}"=Funktion konnte
daher nicht gefunden werden. Das ist problematisch: CUDA"=fähige Beschleuniger
nutzen diese Funktion, um während des Profilings gepufferte
Profiling"=Informationen auf der Festplatte zu speichern. Wird das Programm
vorher beendet, gehen diese Informationen möglicherweise verloren. Aufgrund des
Zustands der zur Verfügung stehenden SYCL"=Implementierungen (siehe
Abschnitt~\ref{ergebnisse:nutzbarkeit}) und der Tatsache, dass NVIDIA ohnehin
kein Profiling für OpenCL"=basierte Programme mehr ermöglicht, kann noch keine
Aussage darüber getroffen werden, inwieweit sich das Fehlen der
\texttt{dev::reset()}"=Funktion für SYCL"=Backends zukünftig bemerkbar machen
wird.

\section{Queues und Events}
\label{implementierung:queue}

Alpaka"=Queues bilden die Schnittstelle zwischen \textit{Host} und
\textit{Device}. Sie nehmen vom \textit{Host} Tasks entgegen und bringen diese
in der Reihenfolge ihres Eingehens zur Ausführung.

Alpaka unterscheidet den \textit{Host} blockierende und nicht-blockierende
Queues. Blockierende Queues unterbrechen die Ausführung auf dem \textit{Host} so
lange, bis alle eingereihten Tasks abgearbeitet sind. Die nicht-blockierenden
Queues führen diese Tasks asynchron zum \textit{Host} aus.

SYCL kennt ausschließlich nicht-blockierende Queues. Da auf diese aber manuell
gewartet werden kann, gestaltete sich die Implementierung der Alpaka"=Queues
sehr einfach. Die Klassen \texttt{QueueSyclBlocking} und
\texttt{QueueSyclNonBlocking} stellen Alpakas Queue"=Funktionalität zur
Verfügung. Lediglich die Implementierung des Event"=Systems bereitete größere
Schwierigkeiten.

\subsection{Event"=Inkompatibilitäten}

Alpaka übernimmt viele CUDA"=Konzepte, darunter auch das Event"=System.
Alpaka"=Events werden wie Tasks in eine Queue eingereiht. Beendet die Queue
einen Task, wird das dahinterliegende Event markiert. Dadurch kann der Nutzer
das Ende eines Kernels abwarten und z.B. einen Task in einer weiteren Queue
starten, was der Organisation der Abhängigkeiten zwischen Kerneln sehr dienlich
ist.

Dieses Prinzip ist in SYCL so nicht vorhanden. Eine SYCL"=Queue führt
grundsätzlich alle Tasks asynchron zueinander aus. Sofern Abhängigkeiten
bestehen, werden diese von der Queue erkannt und entsprechend sortiert. Es ist
also in SYCL nicht notwendig, die Abhängigkeiten zwischen Kerneln selbst zu
verwalten.

Dadurch existiert in SYCL auch kein vergleichbares Event"=System. Zwar erhält
der Programmierer beim Einreihen einer \textit{command group} ein SYCL"=Event
zurück, auf das der Host (und nur der Host) warten kann. Dieses dient aber
vorrangig dem Profiling der Anwendung. Es ist insbesondere für die manuelle
Abhängigkeitsverwaltung ungeeignet, da es zwar das Ende eines Kernels anzeigen
kann, jedoch nicht die Verfügbarkeit der von diesem Kernel verwendeten Puffer.
Über die Puffer"=Verfügbarkeit wird in SYCL die Abhängigkeitsverwaltung
durchgeführt.

Für die Implementierung der Alpaka"=Events stellt dies ein nicht zu lösendes
Problem dar. So ist es beispielsweise in SYCL völlig unmöglich (und unnötig),
eine Queue über Events auf eine weitere Queue warten zu lassen -- genau dieser
Mechanismus ist in Alpakas Interface aber vorgesehen. Analog verhält es sich bei
Alpaka"=\textit{Devices}, die auf Events warten können, während
SYCL"=\textit{Devices} dazu nicht in der Lage sind.

Im Backend"=Prototypen führt der Aufruf der entsprechenden Funktionen dazu, dass
nicht nur die jeweilige Queue auf das Event wartet, sondern zusätzlich auch der
Host. Dadurch wird die eigentliche Intention der Funktionen -- also das in Bezug
auf den \textit{Host} asynchrone Warten -- zwar nicht erfüllt, aber es findet
immerhin eine Synchronisation mit anderen Queues statt. Es besteht dabei aber
weiterhin das Problem, dass es sich dabei nicht um eine echte
Abhängigkeitsverwaltung im Sinne der SYCL"=Spezifikation handelt und deswegen zu
Problemen führen kann.

In der Klasse \texttt{EventSycl} wurde Alpakas Event"=System mit den
beschriebenen Einschränkungen implementiert.

\section{Tasks}
\label{implementierung:task}

Wie im vorherigen Kapitel dargestellt wurde, werden \textit{device}"=seitige
Operationen in Alpaka unter dem Begriff \textit{Task} zusammengefasst. Dazu
gehören neben dem Kernel die Kopier"= und \texttt{memset}"=Operationen.
Alpaka"=Tasks werden in einer Alpaka"=Queue eingereiht und von dieser in der
Reihenfolge ihrer Einreihung ausgeführt. In diesem Abschnitt wird die
Implementierung dieses fundamentalen Alpaka"=Konzepts beschrieben.

\subsection{Kernel"=Tasks}
\label{implementierung:task:kernel}

Ein Alpaka"=Kernel"=Task (im Folgenden als Kernel"=Task bezeichnet) verknüpft
die eigentliche Kernel"=Funktion mit konkreten Daten. Damit ähnelt ein
Kernel"=Task stark SYCLs \textit{command groups}, was die Umsetzung dieses
Konzepts vereinfacht.

Die Struktur \texttt{TaskKernelSycl} enthält die SYCL"=Implementierung der
Kernel"=Tasks. Diese ist aus mehreren Teilen aufgebaut (siehe
Quelltext~\ref{implementierung:task:kernel:struktur}):

\begin{itemize}
    \item Die Struktur wird mit den vier Template"=Parametern \texttt{TDim},
          \texttt{TIdx}, \texttt{TKernelFnObj} und \texttt{TArgs}
          parametrisiert. \texttt{TDim} bezeichnet den Datentyp, der später die
          Dimensionaliät des Algorithmus beschreibt, während \texttt{TIdx} den
          Datentyp des bearbeiteten Indexraums angibt. Diese Parameter werden
          innerhalb des Work=Division=Konzepts -- gekennzeichnet durch die
          Elternklasse \texttt{workDivMembers} -- verwendet, um innerhalb des
          Kernels die Position des jeweiligen \textit{Blocks} oder
          \textit{Threads} bestimmen zu können \texttt{TKernelFnObj} ist der Typ
          bzw. die Signatur der vom Nutzer implementierten Kernel"=Funktion. Der
          variadische Parameter \texttt{TArgs} umfasst die Typen der Parameter
          der Kernel"=Funktion.
    \item Der Konstruktor der Klasse wird während der Instanziierung der Klasse
          aufgerufen und nimmt konkrete Werte für die gewünschte
          Arbeitsaufteilung, den auszuführenden Kernel und die zugehörigen Daten
          an. Die Implementierung des Konstruktors ist im
          Anhang~\ref{anhang:source:cpp:taskkernelsyclkonst} zu finden.
    \item Den Variablen \texttt{m\_kernelFnObj} und \texttt{m\_args} werden vom
          Konstruktor die konkrete Kernelfunktion bzw.\ die zugehörigen Daten
          zugewiesen.
    \item Der \texttt{operator()} bildet die Schnittstelle zur intern
          verwendeten SYCL"=Queue. Durch den Parameter wird der Operator als
          Einstiegspunkt in eine \texttt{command queue} gekennzeichnet, wodurch
          die gesamte Klasse \texttt{TaskKernelSycl} ohne weitere
          Transformationen in eine SYCL"=Queue eingereiht werden kann.
\end{itemize}

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
template <typename TDim, typename TIdx,
          typename TKernelFnObj, typename... TArgs>
class TaskKernelSycl final : public workdiv::workDivMembers<TDim, TIdx>
{
    template <typename TWorkDiv>
    TaskKernelSycl(TWorkDiv&& workDiv,
                   const TKernelFnObj& kernelFnObj,
                   const TArgs&... args);

    TKernelFnObj m_kernelFnObj;
    std::tuple<TArgs...> m_args;

    auto operator()(cl::sycl::handler& cgh);
};
    \end{minted}
    \caption{Aufbau des SYCL"=Kernel"=Tasks}
    \label{implementierung:task:kernel:struktur}
\end{code}

\subsubsection{Vom SYCL- zum Alpaka-Kernel}
\label{implementierung:task:kernel:launch}

In der \textit{command group} wird der eigentliche SYCL"=Kernel gestartet, der
wiederum die vom Nutzer geschriebene Alpaka"=Kernel"=Funktion mit ihren
Parametern aufruft. SYCL stellt drei verschiedene Möglichkeiten für den
Kernel"=Start zur Verfügung (siehe Abschnitt~\ref{sycl:konzepte:kernelstart}:
\texttt{single\_task}, \texttt{parallel\_for} und
\texttt{parallel\_for\_work\_group}.

\texttt{single\_task} stellt keine Parallelität durch \textit{work"=items} zur
Verfügung und ist in seiner Funktion mit einem einzelnen CPU"=Thread
vergleichbar, der auf genau einem CPU"=Kern ausgeführt wird. In Kombination mit
den in Kapitel~\ref{sycl} aufgeführten FPGA"=Erweiterungen ist dieses Verhalten
für FPGAs durchaus sinnvoll, jedoch für CPU"= und GPU"=Beschleuniger wenig
nützlich bis kontraproduktiv. Im Interesse eines portablen Backends scheidet
diese Variante aus.

\texttt{parallel\_for} ist für datenparallele Algorithmen gedacht. Der
Programmierer hat die Möglichkeit, die Zahl der \textit{work"=groups} und ihrer
\textit{work"=items} genau zu spezifizieren. Diese lassen sich einfach auf die
Alpaka"=Äquivalente \textit{Block} und \textit{Thread} Work"=Division"=Konzept
abbilden, weshalb \texttt{parallel\_for} eine gute Wahl für den
SYCL"=Kernel"=Start darstellt.

\texttt{parallel\_for\_work\_group} bietet dieselbe Funktionalität wie
\texttt{parallel\_for}, exponiert diese jedoch mit einem anderen Schwerpunkt.
Mit diesem Ansatz wird der Kernel in zwei separate Bereiche aufgeteilt: Einmal
auf Ebene der \textit{work"=groups} und einmal auf Ebene der
\textit{work"=items}, wobei die letztere der ersteren untergeordnet ist bzw.
aus ihr heraus aufgerufen wird. Befehle auf der \textit{work"=group}"=Ebene
werden genau einmal für die gesamte \textit{work"=group} ausgeführt, Befehle auf
der Ebene der \textit{work"=items} genau einmal pro \textit{work"=item}. Dadurch
hat der Programmierer die Möglichkeit, seine Algorithmen hierarchisch zu
gliedern. Dieses Konzept findet sich nicht in Alpakas Work"=Division"=Konzept,
weshalb in dieser Implementierung \texttt{parallel\_for} als
Kernel"=Start"=Funktion gewählt wurde.

Für die Nutzung der \texttt{parallel\_for}"=Funktion muss die Gesamtanzahl der
\textit{work"=items} sowie die Anzahl der \textit{work"=items} pro
\textit{work"=group} angegeben werden.

Da Alpaka diese Informationen in etwas anderem Format (Anzahl der
\textit{Blocks} und Anzahl der \textit{Threads} pro \textit{Block}) sowie in
eigenen Datenstrukturen enthält, ist eine Konvertierung erforderlich. Die
Funktion \texttt{get\_global\_size()} berechnet aus der Zahl der \textit{Blocks}
und der \textit{Threads} pro \textit{Block} die Gesamtanzahl der
\textit{Threads} (was der Gesamtanzahl der SYCL"=\textit{work"=items}
entspricht) und führt die Konvertierung in ein SYCL"=kompatibles Format durch.
Die Funktion \texttt{get\_local\_size()} nimmt die Zahl der \textit{Threads} und
konvertiert diese in eine SYCL"=Datenstruktur, die die Zahl der
\textit{work"=items} enthält.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
namespace sycl
{
    namespace detail
    {
        template <typename TName>
        struct kernel {};
    }
}

template <typename TDim, typename TIdx,
          typename TKernelFnObj, typename... Args>
class TaskKernelSycl final : public workdiv::WorkDivMembers<TDim, TIdx>
{
    auto operator()(cl::sycl::handler& cgh)
    {
        /* Speicherzuweisung */

        // Work Division
        auto blocks = workdiv::WorkDivMembers<TDim, TIdx>::m_gridBlockExtent;
        auto threads = workdiv::WorkDivMembers<TDim, TIdx>::m_blockThreadExtent;
        auto global_size = get_global_size(blocks, threads);
        auto local_size = get_local_size(threads);

        cgh.parallel_for<sycl::detail::kernel<TKernelFnObj>>(
            cl::sycl::nd_range<TDim::value>{global_size, local_size},
        [=](cl::sycl::nd_item<TDim::value> work_item)
        {
            /* Aufruf des Alpaka-Kernels */
        });
    }
}
    \end{minted}
    \caption{Aufruf der Alpaka-Kernel-Funktion im SYCL-Kernel}
    \label{implementierung:task:kernel:launch}
\end{code}

Wichtig ist ferner der Name des SYCL"=Kernels, der allen
Kernel"=Start"=Varianten übergeben werden muss. In SYCL ist der Kernel"=Name ein
eigener Datentyp, der der Startfunktion als Template"=Parameter übergeben wird,
sich von anderen SYCL"=Kerneln unterscheiden und global sichtbar sein muss.
Daher wurde für das SYCL"=Backend die Klasse \texttt{sycl::detail::kernel}
eingeführt, welche den Typ der Alpaka"=Kernel"=Funktion (\texttt{TKernelFnObj})
als Template"=Parameter entgegennimmt.

Im Quelltext~\ref{implementierung:task:kernel:launch} wird der Vorgang des
Kernel"=Starts gezeigt, jedoch noch ohne \texttt{accessors} -- diese werden
im nächsten Abschnitt behandelt.

\subsubsection{Zeiger und \textit{accessors}}

Innerhalb der \textit{command group} ist eine Transformation der
Datenfeld"=Parameter nötig. In Alpaka erhält die Kernel"=Funktion pro Datenfeld
üblicherweise einen Zeiger, z.B. vom Typ \texttt{float*}, und einen ganzzahligen
Parameter (meist vom Typ \texttt{size\_t}), der die Länge des Speicherbereichs
angibt. Der \textit{device}"=seitige Zeiger wird während der Instanziierung des
Kernel"=Tasks über die Funktion \texttt{getPtrNative()} aus einem Alpaka"=Puffer
extrahiert und an den Kernel übergeben.

Diese Vorgehensweise war mit allen bisher in Alpaka vorhandenen Backends
unproblematisch, wenngleich etwas altmodisch. SYCL verlangt als Parameter für
die Kernel"=Funktionen jedoch die eigenen \texttt{accessor}"=Datenstrukturen.
Eine Übergabe von Zeigern an den Kernel wird in der Spezifikation explizit
verboten \cite[vgl.][192]{sycl2019}. Zwar gibt die Spezifikation an, dass sich
die \texttt{accessor}"=Typen implizit in reine Zeiger umwandeln lassen
\cite[vgl.][27]{sycl2019}, was jedoch von keiner der verfügbaren
Implementierungen unterstützt wird\footnote{Im Rahmen dieser Arbeit wurde der
Konflikt in dieser Frage zwischen der Spezifikation und den vorhandenen
Implementierungen an das SYCL"=Spezifikationskomitee gemeldet. Infolgedessen
wurde der Wortlaut der Spezifikation als Fehler anerkannt, der in zukünftigen
Fassungen der Spezifikation behoben sein wird (siehe die Diskussion in
Anhang~\ref{anhang:diskussion:syclspec:implicitaccessor}).}.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
struct general {};
struct special : general{};
template <typename> struct acc_t { using type = int; };

// spezieller Fall: Puffer-Struktur
template <typename TDim, typename TBuf,
    typename acc_t<typename TBuf::is_alpaka_sycl_buffer_wrapper>::type = 0>
inline auto get_access(cl::sycl::handler& cgh, TBuf buf, special)
{
    return buf.buf.template get_access<
                                cl::sycl::access::mode::read_write,
                                cl::sycl::access::target::global_buffer>(cgh);
}

// allgemeiner Fall: kein Puffer
template <typename TDim, typename TBuf>
inline auto get_access(cl::sycl::handler& cgh, TBuf buf, general)
{
    return buf;
}

template <typename TDim, typename... TArgs, std::size_t... Is>
constexpr auto bind_buffers(cl::sycl::handler& cgh,
                            std::tuple<TArgs...> args,
                            std::index_sequence<Is...>)
{
    return std::make_tuple(get_access<TDim>(cgh,
                                            std::get<Is>(args),
                                            special{})...);
}
    \end{minted}
    \caption{Umwandlung der Puffer in SYCL"=\texttt{accessor}"=Typen durch
             Template"=Meta"=Programmierung}
    \label{implementierung:task:kernel:zeiger:wrappertrans}
\end{code}

Innerhalb eines Kernels lassen sich die \texttt{accessor}"=Typen in spezielle
SYCL"=eigene Zeigertypen (\texttt{multi\_ptr}) umwandeln, die wiederum in
\glqq reine\grqq\ Zeiger konvertierbar sind. Dadurch lässt sich die geschilderte
Problematik in mehreren Stufen lösen:

Auf der \textit{Host}"=Seite wird beim Aufruf der Funktion
\texttt{getPtrNative()} eine Datenstruktur angelegt, die den SYCL"=Puffer
kapselt und sich aus Sicht des Programmierers weitestgehend wie ein normaler
Zeiger verhält. Daneben enthält diese Struktur ein spezielles Attribut mit dem
Namen \texttt{is\_alpaka\_sycl\_buffer\_wrapper}. (Der Quelltext dieser Struktur
ist in Anhang~\ref{anhang:source:cpp:bufferwrapper} zu finden.)

Dieses Attribut wird bei der Nutzung des Kernel"=Objekts verwendet, um die
Puffer"=Strukturen von den restlichen Parametern abzugrenzen. Strukturen, die
dieses Attribut besitzen, werden an eine spezielle Funktion weitergereicht, die
den Zusammenhang zwischen SYCL"=Puffer und SYCL"=\texttt{accessor} herstellt.
Alle anderen Datentypen werden unverändert zurückgegeben. Da Techniken der
Template"=Meta"=Programmierung verwendet werden, finden diese Transformationen
zur Compile"=Zeit statt. Der gesamte Vorgang ist in
Quelltext~\ref{implementierung:task:kernel:zeiger:wrappertrans} dargestellt.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
inline operator()(cl::sycl::handler& cgh)
{
    // transformiere alle Puffer-Parameter in Accessor-Parameter
    auto accessor_args = sycl::detail::bind_buffers<TDim>(
                cgh, m_args,
                std::make_index_sequence<sizeof...(TArgs)>{});

    /* weitere Operationen */
}
    \end{minted}
    \caption{Nutzung der Template"=Meta"=Funktionen zur Umwandlung der
             Puffer"=Wrapper in SYCL"=\texttt{accessor}"=Typen}
    \label{implementierung:task:kernel:zeiger:transusage}
\end{code}

Der Quelltext~\ref{implementierung:task:kernel:zeiger:transusage} zeigt die
Nutzung der Template"=Meta"=Funktionen innerhalb der \textit{command group}:
die in einem \texttt{std::tuple} gespeicherten Kernel"=Parameter werden in ein
SYCL"=kompatibles Format umgewandelt.

Innerhalb des SYCL"=Kernels werden die \texttt{accessor}"=Typen (über SYCLs
\texttt{multi\_ptr}) nach einem ähnlichen Prinzip in reine Zeiger transformiert.
Die Template"=Meta"=Funktionen sind dem oben gezeigten Prinzip sehr ähnlich
und im Anhang~\ref{anhang:source:cpp:kernelzeigeracctrans} gezeigt, deren
Nutzung in Quelltext~\ref{implementierung:task:kernel:zeiger:acctransusage}.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
cgh.parallel_for<sycl::detail::kernel<TKernelFnObj>>(
                    cl::sycl::nd_range<TDim::value> {global_size, local_size},
[=](cl::sycl::nd_item<TDim::value> work_item)
{
    auto pointer_args = transform(
                accessor_args,
                std::make_index_sequence<sizeof...(TArgs)>{});

    /* weitere Operationen und Alpaka-Kernel-Aufruf */
}
    \end{minted}
    \caption{Nutzung der Template"=Meta"=Funktionen zur Umwandlung der
             \texttt{accessor}"=Typen in Zeiger}
    \label{implementierung:task:kernel:zeiger:acctransusage}
\end{code}

Die extrahierten Zeiger werden dann an den vom SYCL"=Kernel aufgerufenen
Alpaka"=Kernel übergeben, sodass der Programmierer diese verwenden kann.
Dadurch lässt sich das SYCL"=Backend analog zu den restlichen Implementierungen
verwenden.

\subsection{Kopier"= und \texttt{memset}"=Tasks}

Im Vergleich zu Kernel"=Tasks gestaltete sich die Implementierung der
Kopier"=Tasks in Form der Struktur \texttt{TaskCopySycl} vergleichsweise
einfach. In ihrem Aufbau sind diese den Kernel"=Tasks recht ähnlich, wie
Quelltext~\ref{implementierung:task:copy:struktur} zeigt.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
template <typename TElem, typename TDim>
struct TaskCopySycl<TElem, TDim, copy_type::host_to_device>
{
    const TElem * const src_ptr;
    cl::sycl::buffer<TElem, TDim::value> dst_buf;
    cl::sycl::range<TDim::value> range;

    auto operator()(cl::sycl::handler& cgh)
    {
        auto dst_acc = dst_buf.template get_access<
                                cl::sycl::access::mode::write>(cgh, range);
        cgh.copy(src_ptr, dst_acc);
    }
};
    \end{minted}
    \caption{Aufbau eines SYCL"=Kopier"=Tasks}
    \label{implementierung:task:copy:struktur}
\end{code}

Der Template"=Parameter \texttt{TElem} definiert den zu kopierenden Datentyp,
während \texttt{TDim} den Typ der Dimensionalität des zu kopierenden Puffers
angibt.  

Der \texttt{operator()} wird durch seinen Parameter eine
SYCL"=\textit{command"=group}. Der \texttt{TaskCopySycl} kann somit von einer
SYCL"=Queue ausgeführt werden.

Die Struktur enthält ansonsten nur die Operanden der Kopier"=Operation und die
Anzahl der zu kopierenden Elemente. Aufgrund der Reihenfolge der Operanden sowie
der Unterscheidung zwischen Zeigern auf der \textit{Host}"=Seite und
SYCL"=Puffern auf der \textit{Device}"=Seite muss die Task"=Struktur für die
möglichen Kopierrichtungen (\textit{Host}"=auf"=\textit{Device},
\textit{Device}"=auf"=\textit{Host}, \textit{Device}"=auf"=\textit{Device})
spezialisiert werden.

Der \texttt{memset}"=Task ähnelt in seinem Aufbau dem Kopier"=Task. Für ihn
entfällt die Angabe der Richtung (und damit die Notwendigkeit der
Spezialisierung), da er immer auf dem \textit{Device} ausgeführt wird. Darüber
hinaus findet er nur auf Puffer des Typs \texttt{uint8\_t}, da es sich hier um
eine byte"=weise Operation handelt. Puffer anderer Typen werden deshalb
als \texttt{uint8\_t}"=Puffer interpretiert. Mit dem Befehl \texttt{cgh.fill()}
lässt sich der Puffer dann Byte für Byte beschreiben.

\section{Work"=Division}
\label{implementierung:workDiv}

Um auf die Positionen der einzelnen \textit{Threads} und \textit{Blocks}
innerhalb des aufgespannten \textit{Grids} zugreifen zu können, stellt Alpaka
in seinem Work"=Division"=Konzept entsprechende Funktionen bereit. Da die Kernel
durch SYCLs \texttt{parallel\_for}"=Funktion gestartet werden, ist innerhalb
des SYCL"=Backends die Datenstruktur \texttt{nd\_item} vorhanden. Diese stellt
äquivalente Funktionalität zur Verfügung, so dass alle
Work"=Division"=Funktionen problemlos implementiert werden konnten.

\section{Geteilter Speicher}
\label{implementierung:shared}

Alpaka stellt einen auf \textit{Block}"=Ebene geteilten Speicher zur Verfügung,
über den die \textit{Threads} des \textit{Blocks} kommunizieren können. Dieser
bietet gegenüber dem globalen Speicher sehr viel schnellere Zugriffe, ist aber
auch deutlich kleiner. 

Es gibt zwei mögliche Arten, Speicher dieses Typs zu reservieren:
\textit{dynamisch}, das heißt außerhalb des Kernel"=Codes und zur Laufzeit,
sowie \textit{statisch}, das heißt innerhalb des Kernel"=Codes und mit einer zur
Compile"=Zeit feststehenden Größe. Alpaka stellt für beide Varianten eine
Schnittstelle bereit.

\subsection{Dynamischer, geteilter Speicher}

Das \textit{type trait} \texttt{kernel::traits::BlockSharedMemDynSizeBytes}
muss für den dynamischen Fall vom Programmierer auf der Host"=Seite für seine
Anwendung implementiert werden. Innerhalb des Kernels kann er dann über die
Alpaka-Funktion \texttt{block::shared::dyn::getMem()} auf den Zeiger zum so
reservierten geteilten Speicher zugreifen.

Dieses Verhalten ließ sich so auch für SYCL implementieren. Dafür musste
lediglich innerhalb der \texttt{TaskKernelSycl}"=Struktur ein
SYCL"=\textit{accessor} für den lokalen Speicher (dem SYCL"=Äquivalent zum
geteilten Speicher) angelegt werden, auf den die genannte Funktion zugreifen und
den zugehörigen Zeiger zurückgeben kann.

\subsection{Statischer, geteilter Speicher}

Für den statischen Fall existiert die Funktion
\texttt{block::shared::st::allocVar()}, die innerhalb des Kernels aufgerufen
wird und Speicherplatz für eine Variable im geteilten Speicher reserviert. Diese
Funktion kann für SYCL nicht implementiert werden, da die SYCL"=Spezifikation
für den Kernel"=Start mit \texttt{parallel\_for} keine äquivalente
Funktionalität bietet.

Diese Einschränkung erklärt sich dadurch, dass SYCL mit dem Anspruch entworfen
wurde, von jedem beliebigen modernen C++"=Compiler übersetzt werden zu können,
auch wenn dieser keine Unterstützung für OpenCL"= und/oder SYCL"=Konzepte mit
sich bringt. In diesem Fall generiert der Compiler wie bei jedem anderen
C++"=Programm normalen CPU"=Maschinencode. Der Umfang des statischen geteilten
Speichers steht zwar bereits zur Compile"=Zeit fest und kann deshalb schon vor
dem Aufruf des Kernels reserviert werden. Der Zeiger auf diesen Speicherbereich
kann durch einen C++"=Compiler ohne SYCL"=Unterstützung dem betreffenden Kernel
vor dessen Ausführung jedoch gar nicht zugeordnet werden, da für diese Funktion
noch kein \textit{stack frame} existiert. Als Reaktion auf eine im Rahmen dieser
Arbeit gestellte Rückfrage zur Sinnhaftigkeit dieser Einschränkung wird vom
SYCL"=Spezifikationskomitee zur Zeit untersucht, inwieweit diese Funktionalität
trotzdem verfügbar gemacht werden kann (vgl. die GitHub"=Diskussion mit
Mitgliedern des SYCL"=Spezifikationskomitees im
Anhang~\ref{anhang:diskussionen:syclspec:staticshared}).

\section{Globale Variablen}\label{implementierung:globalvar}

Die Makros \texttt{ALPAKA\_STATIC\_ACC\_MEM\_GLOBAL} und
\texttt{ALPAKA\_STATIC\_ACC\_MEM\_CONSTANT} werden von Alpaka zur Verfügung
gestellt, um globale Variablen direkt im globalen bzw. konstanten
\textit{Device}"=Speicher anlegen zu können. Diese dienen vornehmlich der
Abstraktion der CUDA"=Schlüsselwörter \texttt{\_\_device\_\_} und
\texttt{\_\_constant\_\_}, die dieselbe Funktion erfüllen. Diese Funktionalität
wurde für die restlichen Alpaka"=Backends bisher nicht benötigt. Im Zusammenhang
mit SYCL kommt es hier jedoch zu Problemen.

Zwar ist das Anlegen globaler \textit{device}"=seitiger Variablen prinzipiell
auch in SYCL möglich, erfordert hier aber den Weg über Puffer und
\textit{accessors}. Die C++"=Makro"=Mächtigkeit reicht allerdings nicht aus, um
aus einer Variablendeklaration

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
ALPAKA_STATIC_ACC_MEM_GLOBAL int x;
    \end{minted}
\end{code}

eine Transformation in einen SYCL"=Puffer sowie einen zugehörigen
\textit{accessor} durchzuführen:

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
cl::sycl::buffer<int, 1>{cl::sycl::range<1>{1}} x_buf;
// im Kernel
auto acc = x_buf.get_access</* ... */>(cgh);
    \end{minted}
\end{code}

Daher konnte die Implementierung der obigen Makros für das SYCL"=Backend nicht
durchgeführt werden.

\section{Mathematikfunktionen}

Bei der Implementierung der von Alpaka vorgegebenen mathematischen Funktionen
kam es zu keinen Schwierigkeiten. SYCL stellt für alle Alpaka"=Funktionen ein
Äquivalent zur Verfügung, das Datentypen mit halber, einfacher und doppelter
Präzision entgegennimmt.

\section{FPGA-Erweiterungen}\label{implementierung:probleme:fpga}

Wie in Abschnitt~\ref{sycl:erweiterungen} dargestellt wurde, existieren einige
SYCL"=Erweiterungen für FPGAs, die eine bessere Nutzung dieser Hardware
ermöglichen sollen. Diese sind naturgemäß nicht auf anderen
Hardware"=Plattformen nutzbar und auch nicht zwischen verschiedenen
FPGAs unterschiedlicher Hersteller kompatibel. Es stellt sich daher die Frage,
wie diese herstellerabhängigen Erweiterungen innerhalb der Alpaka"=Bibliothek
nutzbar gemacht werden können. Für den SYCL"=Backend"=Prototypen wurde auf
Erweiterungen verzichtet, um die Hardware"=Unabhängigkeit nicht zu gefährden.
Dies ist jedoch kein dauerhaft wünschenswerter Zustand, da die Erweiterungen
ganz erhebliche Performanzgewinne zur Folge haben können. Denkbar ist ein
ähnliches Erweiterungskonzept für Alpaka, in welchem dem Nutzer abstrahierte
Formen der SYCL"=Erweiterungen zur Verfügung gestellt werden, die er selbst in
seinem Kernel nutzen kann. Diese bedarf jedoch einer vorherigen Diskussion
innerhalb der Alpaka"=Entwicklergemeinde.

\section{Zufallszahlen und Zeit}

Da SYCL erst vor wenigen Jahren erstmals veröffentlicht wurde, ist das
zugehörige Ökosystem noch nicht sonderlich stark ausgeprägt. So fehlt auch
Funktionalität, die auf Seiten des \textit{Devices} die Generierung von
Zufallszahlen oder Zeitmessung erlauben. Alpaka stellt diese Funktionen jedoch
zur Verfügung. Eine Lösung für dieses Problem konnte im Rahmen dieser Arbeit
nicht gefunden werden, diese Funktionalität fehlt daher für das SYCL"=Backend.

\section{Zusammenfassung}

Der strukturelle Aufbau des SYCL"=Backends bzw.\ die in ihm abgebildeten
Alpaka"=Konzepte sind in der
Abbildung~\ref{implementierung:zusammenfassung:struktur} zusammengefasst. Dabei
zeigt blau eine Implementierung aller Features des zugrunde liegenden Konzepts,
gelb die Implementierung einer Teilmenge des Konzepts und lila eine
nicht erfolgte Implementierung.

Insgesamt umfasst das Backend \num{5011} Zeilen C++"=Quelltext (ohne Kommentare
und Leerzeilen).

\begin{figure}
    \centering
    \begin{tikzpicture}
        \draw [rounded corners, fill = HKS33!70] (0, 0) rectangle (2.5, 9.5)
              node [pos = 0.5, align = center, rotate = 90] {\color{white}\textbf{Device}};
        \draw [rounded corners, fill = HKS33!70] (0, 9.75) rectangle (2.5, 19.85)
              node [pos = 0.5, align = center, rotate = 90] {\color{white}\textbf{Host}};
        \draw [rounded corners, fill = HKS33!100] (0, 20.1) rectangle (2.5, 22.1)
              node [pos = 0.5, align = center] {\color{white}\textbf{Domäne}};

        \draw [rounded corners, fill = HKS65!70] (2.75, 0) rectangle (3.95, 8.4)
              node [pos = 0.5, align = center, rotate = 90] {\color{white}\textbf{Alpaka}};
        \draw [rounded corners, fill = HKS65!70] (4.05, 0) rectangle (5.25, 8.4)
              node [pos = 0.5, align = center, rotate = 90] {\color{white}\textbf{Nutzer}};
        \draw [rounded corners, fill = HKS65!70] (2.75, 8.5) rectangle (5.25, 9.5)
              node [pos = 0.5, align = center] {\color{white}\textbf{Nutzer}};
        \draw [rounded corners, fill = HKS65!70] (2.75, 9.75) rectangle (3.95, 19.85)
              node [pos = 0.5, align = center, rotate = 90] {\color{white}\textbf{Alpaka}};
        \draw [rounded corners, fill = HKS65!70] (4.05, 9.75) rectangle (5.25, 19.85)
              node [pos = 0.5, align = center, rotate = 90] {\color{white}\textbf{Nutzer}};
        \draw [rounded corners, fill = HKS65!100] (2.75, 20.1) rectangle (5.25, 22.1)
              node [pos = 0.5, align = center] {\color{white}\textbf{Ursprung}};

        \draw [rounded corners, fill = HKS07!70] (5.5, 0) rectangle (8, 8.4);
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 0.1) rectangle (7.9, 0.85)
              node [pos = 0.5, align = center] {\color{white}\textbf{\ldots}};
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 1.05) rectangle (7.9, 2.05)
              node [pos = 0.5, align = center] {\color{white}\textbf{Math}};
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 2.15) rectangle (7.9, 3.15)
              node [pos = 0.5, align = center] {\color{white}\textbf{Rand}\\
                                                \color{white}\textbf{Time}};
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 3.25) rectangle (7.9, 4.25)
              node [pos = 0.5, align = center] {\color{white}\textbf{Atomic}};
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 4.35) rectangle (7.9, 5.35)
              node [pos = 0.5, align = center] {\color{white}\textbf{Index}};
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 5.45) rectangle (7.9, 6.45)
              node [pos = 0.5, align = center] {\color{white}\textbf{Work}\\
                                                \color{white}\textbf{Division}};
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 6.65) rectangle (7.9, 7.15)
              node [pos = 0.5, align = center] {\color{white}\textbf{Size}};
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 7.25) rectangle (7.9, 7.75)
              node [pos = 0.5, align = center] {\color{white}\textbf{Dim}};
        \node [align = center] (acctext) at (6.75, 8.10) {\color{white}\textbf{Accelerator}}; 
        \draw [rounded corners, fill = HKS07!70] (5.5, 8.5) rectangle (8, 9.5)
              node [pos = 0.5, align = center] {\color{white}\textbf{Kernel}};
        \draw [rounded corners, fill = HKS07!70] (5.5, 9.75) rectangle (8, 11.45);
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 9.85) rectangle (7.9, 10.35)
              node [pos = 0.5, align = center] {\color{white}\textbf{Size}};
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 10.45) rectangle (7.9, 10.95)
              node [pos = 0.5, align = center] {\color{white}\textbf{Dim}};
        \node [align = center] (tasktext) at (6.75, 11.2) {\color{white}\textbf{Task}};
        \draw [rounded corners, fill = HKS07!70] (5.5, 11.55) rectangle (8, 15.05);
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 11.65) rectangle (7.9, 14.55);
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.7, 11.75) rectangle (7.8, 12.25)
              node [pos = 0.5, align = center] {\color{white}\textbf{Size}};
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.7, 12.35) rectangle (7.8, 12.85)
              node [pos = 0.5, align = center] {\color{white}\textbf{Dim}};
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.7, 12.95) rectangle (7.8, 13.45)
              node [pos = 0.5, align = center] {\color{white}\textbf{Extent}};
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.7, 13.55) rectangle (7.8, 14.05)
              node [pos = 0.5, align = center] {\color{white}\textbf{Offset}};
        \node [align = center] (viewtext) at (6.75, 14.3) {\color{white}\textbf{View}};
        \node [align = center] (buffertext) at (6.75, 14.8) {\color{white}\textbf{Buffer}};
        \draw [rounded corners, fill = HKS07!70] (5.5, 15.15) rectangle (8, 16.25);
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 15.25) rectangle (7.9, 15.75)
              node [pos = 0.5, align = center] {\color{white}\textbf{Waitable}};
        \node [align = center] (eventtext) at (6.75, 16) {\color{white}\textbf{Event}};
        \draw [rounded corners, fill = HKS07!70] (5.5, 16.35) rectangle (8, 17.45);
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 16.45) rectangle (7.9, 16.95)
              node [pos = 0.5, align = center] {\color{white}\textbf{Waitable}};
        \node [align = center] (eventtext) at (6.75, 17.2) {\color{white}\textbf{Queue}};
        \draw [rounded corners, fill = HKS07!70] (5.5, 17.55) rectangle (8, 18.65);
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 17.65) rectangle (7.9, 18.15)
              node [pos = 0.5, align = center] {\color{white}\textbf{Waitable}};
        \node [align = center] (eventtext) at (6.75, 18.4) {\color{white}\textbf{Device}};
        \draw [rounded corners, fill = HKS07!70] (5.5, 18.75) rectangle (8, 19.85)
              node [pos = 0.5, align = center] {\color{white}\textbf{Device}\\
                                                \color{white}\textbf{Manager}};
        \draw [rounded corners, fill = HKS07!100] (5.5, 20.1) rectangle (8, 22.1)
              node [pos = 0.5, align = center] {\color{white}\textbf{Konzept}};


        \draw [rounded corners, fill = HKS44!70] (8.25, 0) rectangle (12.75, 8.4);
        \draw [rounded corners, draw = white, fill = HKS44!50] (8.35, 1.05) rectangle (12.65, 2.05)
              node [pos = 0.5, align = center] {\color{white}\texttt{MathSycl}};
        \draw [rounded corners, draw = white, fill = HKS36!50] (8.35, 2.15) rectangle (12.65, 3.15)
              node [pos = 0.5, align = center] {\color{white}\textbf{nicht implementiert}};
        \draw [rounded corners, draw = white, fill = HKS57!50] (8.35, 3.25) rectangle (12.65, 4.25)
              node [pos = 0.5, align = center] {\color{white}\texttt{AtomicSycl}};
        \draw [rounded corners, draw = white, fill = HKS44!50] (8.35, 4.35) rectangle (12.65, 5.35)
              node [pos = 0.5, align = center] {\color{white}\texttt{IdxBtSycl}};
        \draw [rounded corners, draw = white, fill = HKS44!50] (8.35, 5.45) rectangle (12.65, 6.45)
              node [pos = 0.5, align = center] {\color{white}\texttt{WorkDivSycl}};

        \node [align = center] (accsycltext) at (10.5, 8.10) {\color{white}\texttt{AccSycl}};
        \draw [rounded corners, fill = HKS44!70] (8.25, 8.5) rectangle (12.75, 9.5)
              node [pos = 0.5, align = center] {\color{white}\textbf{\ldots}};
        \draw [rounded corners, fill = HKS44!70] (8.25, 9.75) rectangle (12.75, 11.45)
              node [pos = 0.5, align = center] {\color{white}\texttt{TaskKernelSycl}\\
                                                \color{white}\texttt{TaskCopySycl}\\
                                                \color{white}\texttt{TaskSetSycl}};
        \draw [rounded corners, fill = HKS44!70] (8.25, 11.55) rectangle (12.75, 15.05)
              node [pos = 0.5, align = center] {\color{white}\texttt{BufSycl}};
        \draw [rounded corners, fill = HKS57!70] (8.25, 15.15) rectangle (12.75, 16.25)
              node [pos = 0.5, align = center] {\color{white}\texttt{EventSycl}};
        \draw [rounded corners, fill = HKS57!70] (8.25, 16.35) rectangle (12.75, 17.45)
              node [pos = 0.5, align = center] {\color{white}\texttt{QueueSyclNonBlocking}\\
                                                \color{white}\texttt{QueueSyclBlocking}};
        \draw [rounded corners, fill = HKS57!70] (8.25, 17.55) rectangle (12.75, 18.65)
              node [pos = 0.5, align = center] {\color{white}\texttt{DevSycl}};
        \draw [rounded corners, fill = HKS57!70] (8.25, 18.75) rectangle (12.75, 19.85)
              node [pos = 0.5, align = center] {\color{white}\texttt{PltfSycl}};
        \draw [rounded corners, fill = HKS44!100] (8.25, 20.1) rectangle (12.75, 22.1)
              node [pos = 0.5, align = center] {\color{white}\textbf{Implementierung}};
    \end{tikzpicture}
    \caption[Struktureller Aufbau des SYCL"=Alpaka"=Backends]{Struktureller
             Aufbau des SYCL"=Alpaka"=Backends. Blau zeigt eine vollständige
             Implementierung an, dunkelgrün eine unvollständige Implementierung
             und lila signalisiert das vollständige Fehlen einer
             Implementierung.}
    \label{implementierung:zusammenfassung:struktur}
\end{figure}
