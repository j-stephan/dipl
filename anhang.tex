\chapter{Quelltexte}

\section{VHDL-Quelltexte}\label{anhang:source:vhdl}

\begin{code}
    \begin{minted}[fontsize=\small]{vhdl}
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY ff2 IS
    PORT (
        clk : IN    std_logic;
        d0  : IN    std_logic;
        d1  : IN    std_logic;
        res : IN    std_logic;
        q0  : OUT   std_logic;
        q1  : OUT   std_logic
    );
END ff2 ;

ARCHITECTURE beh OF ff2 IS
    SIGNAL q0_s, q1_s : std_logic;
BEGIN
    
    reg: PROCESS (clk, res)
    BEGIN
        IF res = '1' THEN
            q0_s <= '0';
            q1_s <= '0';
        ELSIF clk'event AND clk = '1' THEN
            q0_s <= d0;
            q1_s <= d1;
        END IF;
    END PROCESS reg;

    q0 <= q0_s AFTER 2 ns;
    q1 <= q1_s AFTER 2 ns;

END beh;
    \end{minted}
    \caption[VHDL-Quelltext eines 2-Bit-Flipflops]
            {VHDL-Quelltext eines 2-Bit-Flipflops \cite[siehe][39]{kesel2013}}
\end{code}

\begin{code}
    \begin{minted}[fontsize=\small]{vhdl}
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY mux2 IS
    PORT (
        a1  : IN    std_logic;
        a2  : IN    std_logic;
        b1  : IN    std_logic;
        b2  : IN    std_logic;
        sel : IN    std_logic;
        o1  : OUT   std_logic;
        o2  : OUT   std_logic
    );
END mux2 ;

ARCHITECTURE beh OF mux2 IS
BEGIN

    mux: PROCESS (a1, a2, b1, b2, sel)
    BEGIN
        IF sel = '1' THEN
            o1 <= a1 after 3 ns;
            o2 <= a2 after 3 ns;
        ELSE
            o1 <= b1 after 4 ns;
            o2 <= b2 after 4 ns;
        END IF;
    END PROCESS mux;

END beh;
    \end{minted}
    \caption[VHDL-Quelltext eines 2-Bit-Multiplexers]
            {VHDL-Quelltext eines 2-Bit-Multiplexers \cite[siehe][39--40]{kesel2013}}
\end{code}

\section{C++"=Quelltexte}
\label{anhang:source:cpp}

\subsection{Verwendung von SYCL-Ausnahmefehlern}
\label{anhang:source:cpp:syclexceptions}

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
#include <cstdlib>
#include <CL/sycl.hpp>

class XOCLDeviceSelector : public cl::sycl::device_selector {
    /* ... */
};

auto main() -> int
{
    try
    {
        auto exception_handler = [] (cl::sycl::exception_list exceptions)
        {
            for(std::exception_ptr e : exceptions)
            {
                try
                {
                    std::rethrow_exception(e);
                }
                catch(const cl::sycl::exception& err)
                {
                    /* Fehlerbehandlung Device */
                }
            }
        };

        // Beschleunigerwahl und Befehlswarteschlange
        auto queue = cl::sycl::queue{XOCLDeviceSelector{},
                                     exception_handler};

        /* ... */

        // Synchronisierung und Ausnahmefehler
        queue.wait_and_throw();
    }
    catch(const cl::sycl::exception& err)
    {
        /* Fehlerbehandlung Host */
    }

    return EXIT_SUCCESS;
}
    \end{minted}
    \caption{Verwendung von SYCL"=Ausnahmefehlern}
\end{code}

\subsection{Verwendung des SYCL"=Profilings}
\label{anhang:source:cpp:syclprofiling}

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
#include <cstdlib>
#include <CL/sycl.hpp>

class XOCLDeviceSelector : public cl::sycl::device_selector {
    /* ... */
};

auto main() -> int
{
    // Beschleunigerwahl und Befehlswarteschlange
    auto queue = cl::sycl::queue{XOCLDeviceSelector{},
                                 cl::sycl::property::queue::enable_profiling{}};

    // Kernel-Event generieren
    auto event = queue.submit(/* ... */);

    // Ausführungsstatus abfragen - Rückgabe: submitted, running oder complete
    auto status =
        event.get_info<cl::sycl::info::event::command_execution_status>();

    // Synchronisierung
    queue.wait();

    // Profilinginformationen abfragen - Rückgabe: Zeitpunkt in ns
    auto start =
        event.get_profiling_info<
                            cl::sycl::info::event_profiling::command_start>();
    auto stop =
        event.get_profiling_info<cl::sycl::info::event_profiling::command_end>();

    auto duration = stop - start;

    return EXIT_SUCCESS;
}
    \end{minted}
    \caption{Verwendung des SYCL"=Profilings}
\end{code}

\subsection{Implementierung des TaskKernelSycl-Konstruktors}
\label{anhang:source:cpp:taskkernelsyclkonst}

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
template <typename TWorkDiv>
TaskKernelSycl(TWorkDiv&& workDiv,
               const TKernelFnObj& kernelFnObj,
               const TArgs&... args)
: workdiv::WorkDivMembers<TDim, TIdx>(std::forward<TWorkDiv>(workDiv))
, m_kernelFnObj{kernelFnObj}
, m_args{args...}
{
}
    \end{minted}
    \caption{Implementierung des Konstruktors der \texttt{TaskKernelSycl}"=Klasse}
\end{code}

\subsection{Implementierung des SYCL-Puffer-Wrappers}
\label{anhang:source:cpp:bufferwrapper}

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
namespace alpaka
{
    namespace mem
    {
        namespace buf
        {
            namespace sycl
            {
                namespace detail
                {
                    template <typename TBuf>
                    struct buffer_wrapper
                    {
                        using buf_type = TBuf;
                        using value_type = typename buf_type::value_type;
                        using is_alpaka_sycl_buffer_wrapper = bool;

                        buffer_wrapper(TBuf wrapped_buf) noexcept
                        : buf{wrapped_buf}
                        , dummy{std::aligned_alloc(alignof(value_type),
                                                   sizeof(std::size_t)),
                                [](void* ptr) { std::free(ptr); }}
                        {
                        }

                        operator value_type*() noexcept
                        {
                            return reinterpret_cast<value_type*>(dummy.get());
                        }

                        operator const value_type*() const noexcept
                        {
                            return reinterpret_cast<const value_type*>(
                                                                dummy.get());
                        }

                        TBuf buf;
                        std::shared_ptr<void> dummy;
                    };
                }
            }
        }
    }
}
    \end{minted}
    \caption{Implementierung des SYCL-Puffer-Wrappers}
\end{code}

\subsection{Umwandlung der Puffer in SYCL"=\texttt{accessor}"=Typen}
\label{anhang:source:cpp:kernelzeigeracctrans}

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
struct general {};
struct special : general{};
template <typename> struct acc_t { using type = int; };

// spezieller Fall: Accessor
template <typename TAccessor,
    typename acc_t<decltype(
        std::declval<TAccessor>().get_pointer())>::type = 0>
inline auto get_pointer(TAccessor accessor, special)
{
    return static_cast<typename TAccessor::value_type*>(
                                    accessor.get_pointer());
}

// allgemeiner Fall: kein Accessor
template <typename TAccessor>
inline auto get_pointer(TAccessor accessor, general)
{
    return accessor;
}

template <typename... TArgs, std::size_t... Is>
constexpr auto transform(std::tuple<TArgs...> args,
                         std::index_sequence<Is...>)
{
    return std::make_tuple(get_pointer(std::get<Is>(args),
                                       special{})...);
}
    \end{minted}
    \caption{Umwandlung der Puffer in SYCL"=\texttt{accessor}"=Typen durch
             Template"=Meta"=Programmierung}
\end{code}

\subsection{Box-Filter-Kernel}
\label{anhang:source:cpp:boxkernel}

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
cgh.single_task<box_filter>([=]() { for(auto y = 0ul; y < dim_y; ++y) {
    for(auto c = 0ul; c < (dim_x / chunk_size); ++c) {
        const auto cl_id = cl::sycl::id<2>{c * chunk_size - 1ul, y};
        const auto left = (c == 0ul) ? 0 : buffers_in[cl_id];
        /* right analog */

        // lese 3 Zeilen aus globalem in lokalen Speicher
        cl::sycl::xilinx::pipeline([&]() {
            for(auto x = 0ul; x < chunk_size; ++x) {
                if(y == 0ul) {
                    const auto local = cl::sycl::id<2>{x, 0ul};
                    local_in[local] = 0.0;
                } else {
                    const auto global = cl::sycl::id<2>{
                                            c * chunk_size + x, y - 1ul}; 
                    const auto local = cl::sycl::id<2>{x, 0ul};
                    local_in[local] = buffers_in[global];
                }
            }
        }); /* Zeilen 2 und 3 analog */

        cl::sycl::xilinx::pipeline([&]() { // box filter
            for(auto x = 0ul; x < chunk_size; ++x) {
                const auto tl_id = cl::sycl::id<2>{x - 1ul, 0ul};
                const auto tl = (x == 0ul) ? left : local_in[tl_id];
                /* cl und bl analog */
                const auto tc_id = cl::sycl::id<2>{x, 0ul};
                const auto tc = local_in[tc_id];
                /* cc und bc analog */
                const auto tr_id = cl::sycl::id<2>{x + 1ul, 0ul};
                const auto tr = (x == (chunk_size - 1ul)) ?
                                    right : local_in[tr_id];
                /* cr und br analog */
                const auto top = tl + tc + tr;
                const auto center = cl + cc + cr;
                const auto bottom = bl + bc + br;

                const auto local = cl::sycl::id<1>{x};
                local_out[local] = (top + center + bottom) / 9;
            }
        });

        // schreibe Ergebnis in globalen Speicher
        cl::sycl::xilinx::pipeline([&]() {
            for(auto x = 0ul; x < chunk_size; ++x) {
                const auto global = cl::sycl::id<2>{c * chunk_size + x, y};
                const auto local = cl::sycl::id<1>{x};
                buffers_out[global] = local_out[local];
            }
        });
    }
}});
    \end{minted}
    \caption{SYCL"=Box"=Filter"=Kernel}
\end{code}

\chapter{Online-Diskussionen}\label{anhang:diskussionen}

\section{Diskussionen mit dem SYCL-Spezifikationskomitee}
\label{anhang:diskussionen:syclspec}

\subsection{Implicit accessor-to-pointer casts}
\label{anhang:diskussion:syclspec:implicitaccessor}

Original: \url{https://github.com/KhronosGroup/SYCL-Docs/issues/11}, zuletzt
abgerufen am 06. November 2019.

\begin{otherlanguage}{english}
    \paragraph{Jan Stephan} This is a duplicate of triSYCL/triSYCL\#247, moving
                            the discussion here.
                            \subparagraph{The Problem} The SYCL specification
                            (3.5.2.1) says the following:
                            \begin{quote}
                                Within kernels, accessors can be implicitly cast
                                to C++ pointer types. The pointer types will
                                contain a compile-time deduced address space.
                                So, for example, if an accessor to global memory
                                is cast to a C++ pointer, the C++ pointer type
                                will have a global address space attribute
                                attached to it. The address space attribute will
                                be compile-time propagated to other pointer
                                values when one pointer is initialized to
                                another pointer value using a defined mechanism.
                            \end{quote}
                            This is not reflected in \texttt{accessor}'s
                            interface and none of the publicly available
                            implementations support this.
                            \subparagraph{Example} $~$ \\
                            \begin{code}
                                \begin{minted}[fontsize=\small]{c++}
void vec_add(const int* a, const int* b, int* c, std::size_t size);

queue.submit([&](cl::sycl::handler& cgh)
{
    auto a = a_d.get_access<cl::sycl::access::mode::read>(cgh);
    auto b = b_d.get_access<cl::sycl::access::mode::read>(cgh);
    auto c = c_d.get_access<cl::sycl::access::mode::discard_write(cgh);

    cgh.single_task<class vector_add>([=]()
    {
        // no known conversion from accessor to const int*
        vec_add(a, b, c, 1024);
    });
});
                                \end{minted}
                            \end{code}
                            \subparagraph{Use case}
                            Libraries such as Alpaka or HPX provide abstraction
                            layers over competing compute APIs such as CUDA.
                            Unfortunately their API works with raw pointers in
                            their abstract kernels. In order to implement a SYCL
                            backend the \texttt{accessor} has to be explicitly
                            transformed into a pointer right now (by going
                            through \texttt{multi\_ptr}). Being able to do this
                            implicitly would be a lot easier.
                            \subparagraph{Possible solutions}
                            \begin{enumerate}
                                \item Remove the above wording and rely on
                                      \texttt{multi\_ptr}'s conversion instead.
                                \item Allow \texttt{accessor} to be implicitly
                                      cast as well.
                            \end{enumerate}
    \paragraph{Ronan Keryell (Xilinx)} The working group is looking at this
                                       internally.
    \paragraph{Ruymán Reyes Castro (Codeplay)} Internal issue tracker: \url{https://gitlab.khronos.org/sycl/Specification/issues/258},
                                               currently assigned to Codeplay.
    \paragraph{Ruymán Reyes Castro} Decision has been to go for option 1, MR up
                                    in: \#44
    \paragraph{Gordon Brown (Codeplay)} SYCL working group: The above merge
                                        request has been approved so we can
                                        close this now.
\end{otherlanguage}

\subsection{Why is there no way to allocate local memory inside a ND-kernel?}
\label{anhang:diskussionen:syclspec:staticshared}

Original: \url{https://github.com/KhronosGroup/SYCL-Docs/issues/20}, zuletzt
abgerufen am 06. November 2019.

\begin{otherlanguage}{english}
    \paragraph{Jan Stephan} I know this is possible using the hierarchical
                            \texttt{parallel\_for} invoke, but we can't do it
                            with the \texttt{nd\_item} version despite being
                            able to specify the group size. OpenCL allows this
                            (AFAIK), SYCL's competitors do, too, so why not
                            allow it in SYCL? I suppose there must be a reason
                            for leaving it out.
    \paragraph{Victor Lomuller (Codeplay)} The main reason is the host device.
                            If your compiler is not SYCL aware, you need to be
                            able to preallocate this memory before calling the
                            functor, which is not trivial without compiler
                            support.
    \paragraph{Jan Stephan} Wouldn't this be solvable by doing the inverse of
                            the hierarchical case? I.e. everything is
                            \texttt{private} by default if declared inside the
                            kernel, unless embedded with something like
                            \texttt{cl::sycl::local\_memory}.
    \paragraph{Victor Lomuller} It does not address the compiler support
                                problem. You still need to preallocate memory
                                before calling the functor, but without compiler
                                support, you cannot know the amount of memory
                                you need nor where to place the pointer to that
                                memory (the stack frame does not exist yet).
    \paragraph{Ronan Keryell (Xilinx)} which SYCL competitor can run on CPU
                              without a specific compiler? This allows for
                              example to use HellGrind \& ThreadSanitizer with
                              plain GCC or Clang to debug a SYCL program just by
                              running it on my laptop. I find this an amazing
                              feature of SYCL...
    \paragraph{Gordon Brown (Codeplay)} SYCL working group: We agree this would
                                        be a useful feature to have, we are
                                        investigating how to potentially support
                                        this internally.
\end{otherlanguage}

\newpage
\subsection{How to extract address space from raw pointers?}
\label{anhang:diskussionen:syclspec:addressspace}

Original: \url{https://github.com/KhronosGroup/SYCL-Docs/issues/21}, zuletzt
abgerufen am 06. November 2019.

\begin{otherlanguage}{english}
    \paragraph{Jan Stephan} Imagine a device-side function with the following
                            signature:
                            \begin{code}
                                \begin{minted}[fontsize=\small]{c++}
void foo(int* vec);
                                \end{minted}
                            \end{code}
                            I don't know if \texttt{vec} comes from global,
                            local, constant or private memory. However, inside
                            \texttt{foo} I'd like to do something to
                            \texttt{vec} which requires me to know the address
                            space of the pointer, e.g. a
                            \texttt{cl::sycl::atomic\_fetch\_add}. How do I tell
                            the \texttt{multi\_ptr} / \texttt{atomic} inside
                            \texttt{foo} which address space is needed? Simply
                            using a \texttt{global\_ptr} will break if
                            \texttt{vec} actually resides in local memory. Using
                            \texttt{multi\_ptr} will fail because the address
                            space template parameter is missing. Creating an
                            \texttt{atomic} by passing \texttt{vec} to its
                            constructor will fail because \texttt{vec} isn't a
                            \texttt{multi\_ptr}. Using
                            \texttt{atomic\_fetch\_add} on \texttt{vec} will
                            fail because \texttt{vec} isn't an \texttt{atomic}
                            type.
                            \\
                            Some implementations (like ComputeCpp) internally
                            use \texttt{\_\_global} to annotate the pointer
                            during device compilation. But even if there was a
                            way to write something like\\
                            \texttt{void foo(\_\_global int* vec)}
                            (there isn't as far as I know, ComputeCpp complains
                            if I do this) this would be a bad idea because the
                            address space attributes are implementation-defined.
                            \\
                            Why do we need this? Sadly, there are libraries /
                            frameworks out there that pass around raw pointers
                            but where a SYCL backend is planned / worked on.
                            \\
                            Edit: I also tried to overload \texttt{foo} with
                            \texttt{global\_ptr}, \texttt{local\_ptr} etc.
                            directly. This will fail because the call is
                            ambigous.
    \paragraph{Ronan Keryell (Xilinx)} Interestingly, Intel is trying hard to
                                       hide what you are asking for:\\
                                       \texttt{intel/llvm\#348}\footnote{Verweis
                                       auf Änderung des Intel-SYCL-Compilers, 
                                       J.S.}. Can you imagine an API that could
                                       be added to the standard?
    \paragraph{Jan Stephan} An easy solution that doesn't require an API change
                            would be to correctly deduce the overloads, i.e.
                            \texttt{foo(global\_ptr)}, \texttt{foo(local\_ptr)}
                            and so on. This is not very intuitive, though, and
                            might break user APIs.
                            \\
                            From the programmer's point of view it would be
                            preferable to allow \texttt{multi\_ptr}
                            construction on raw pointers without having to
                            specify the address space. The compiler should be
                            able to figure this out by itself since it knows
                            about the address spaces anyway.
                            \\
                            On the other hand it should raise an error if the
                            programmer tries to assign a raw pointer in local
                            space to a \texttt{global\_ptr}. Currently this
                            doesn't happen, both the Intel and ComputeCpp
                            compiler will happily compile if I pass the same
                            pointer to \texttt{global\_ptr}'s and
                            \texttt{local\_ptr}'s constructor.
                            \\
                            Admittedly I haven't given this much thought yet (I
                            only encountered the problem on Wednesday), I'll try
                            to think this through on the weekend.
    \paragraph{Jan Stephan} The weekend has passed... Apart from the solutions
                            above the best I could come up with is something
                            like \texttt{cl::sycl::pointer\_traits} to be added
                            to the specification. The interface would look
                            something along the lines of
                            \begin{code}
                                \begin{minted}[fontsize=\small]{c++}
template <typename Ptr>
struct pointer_traits
{
    static_assert(is_raw_ptr_type(Ptr), "Ptr needs to be a raw pointer type");
    using pointer_t = /* implementation-defined */ Ptr;
    using address_space = /* implementation-defined */;
    // maybe add other traits here
};
                                \end{minted}
                            \end{code}
                            Since the compiler needs to figure out the address
                            space on its own anyway (if I understand Section 6.8
                            correctly), it would fill out the
                            \texttt{implementation-defined} parts. A programmer
                            could then use SFINAE or \texttt{if constexpr} to
                            adapt to the different address spaces.
                            \\
                            This is basically the problem \texttt{multi\_ptr}
                            tries to solve, it already encapsulates the
                            functionality above. However, \texttt{multi\_ptr}
                            requires the user to specify the address space
                            before using it. This makes sense because we can
                            request a \texttt{multi\_ptr} from a buffer
                            accessor, a local accessor, and so on and the
                            \texttt{multi\_pt}r data structure has to know about
                            its address space. It also renders us unable to
                            construct it from a pointer we don't know the
                            address space of.
                            \\
                            So my straight-forward resolution still is to remove
                            the requirement to specify the address space for the
                            \texttt{multi\_ptr} type. Instead the compiler needs
                            to figure out the correct value for the
                            \texttt{address\_space} member of
                            \texttt{multi\_ptr} (or the \texttt{Space} template
                            parameter). If this is not an option because of
                            implications I'm not aware of (and I'm sure there
                            are plenty) I'd shoot for the
                            \texttt{pointer\_traits} option.
    \paragraph{Ronan Keryell} \begin{quote}
                                Since the compiler needs to figure out the
                                address space on its own anyway (if I understand
                                Section 6.8 correctly), it would fill out the
                                implementation-defined parts. A programmer could
                                then use SFINAE or \texttt{if constexpr} to
                                adapt to the different address spaces.
                              \end{quote}
                              The problem is that this address space resolution
                              can be done in LLVM or even in the SPIR-V backend
                              or whatever... So you might not have this
                              information inside Clang as a type trait... :-(
                              \\
                              \texttt{multi\_ptr} was designed:
                              \begin{itemize}
                                  \item to avoid requiring this kind of
                                        address-space inference by avoiding
                                        using raw pointers. Of course this means
                                        passing around the \texttt{multi\_ptr}
                                        type. But with \texttt{auto} nowadays it
                                        is easier;
                                  \item to provide a way to interoperate with
                                        existing OpenCL C kernel code. But since
                                        there is no type inference in OpenCL C
                                        either, you have to do an explicit
                                        dispatch yourself from the
                                        \texttt{multi\_ptr} to call an OpenCL
                                        function with different version and
                                        different names for each possible
                                        address-space...
                              \end{itemize}
    \paragraph{Jan Stephan} \begin{quote}
                                The problem is that this address space
                                resolution can be done in LLVM or even in the
                                SPIR-V backend or whatever... So you might not
                                have this information inside Clang as a type
                                trait... :-(
                            \end{quote}
                            I have to admit that my knowledge about compiler
                            construction is a bit limited. But the backends will
                            have to look up this information, too - why can't
                            the frontend do the same?
                            \begin{quote}
                                to avoid requiring this kind of address-space
                                inference by avoiding using raw pointers. Of
                                course this means passing around the
                                multi\_ptr type. But with auto nowadays it is
                                easier;
                            \end{quote}
                            While I can understand this intent with regard to
                            new code I believe this is an oversight if we
                            consider legacy code bases. If those have a raw
                            pointer API the design of \texttt{multi\_ptr} or
                            the lack of a feature to otherwise extract the
                            address space becomes a major obstacle.
\end{otherlanguage}

\section{Diskussionen mit Xilinx-Angestellten}
\label{anhang:diskussionen:xilinx}

\subsection{[SYCL][XilinxFPGA] Known Issues}
\label{anhang:diskussionen:xilinx:knownissues}

Original: \url{https://github.com/triSYCL/sycl/issues/40}, zuletzt abgerufen am
27. November 2019.

\begin{otherlanguage}{english}
    \paragraph{Andrew Gozillon (Xilinx)} This is a non-exhaustive list of some
                                         larger problems relating to XIlinx FPGA
                                         compilation and runtime execution (some
                                         with more information than others) that
                                         need some thought long term:\\
                                         \\
                                         \textbf{Problem:} If you create buffers
                                         and try to use some SYCL functionality
                                         that makes use of some underlying
                                         OpenCL functionality to modify the
                                         buffers as cl\_mem objects before a
                                         kernel is invoked
                                         (single\_task/parallel\_for etc.)
                                         you'll incur XRT runtime errors e.g.:
                                         \\
                                         \textbf{[XRT] ERROR: Internal error.
                                         cl\_mem doesn't map to buffer object}
                                         \\
                                         You should be able to see this in
                                         action if you comment out the "noop"
                                         SYCL kernel in the accessor\_copy.cpp
                                         test.
                                         \\
                                         \textbf{Reason:} XRT will not consider
                                         a device as ``active'' and use-able
                                         until you've loaded a binary as it
                                         can't query most of the information it
                                         needs, one unfortunate side affect of
                                         this is that cl\_mem buffers are not
                                         appropriately assigned to a device and
                                         whenever you try to use something like
                                         a handler copy with a sycl
                                         accessor/buffer the underlying XRT
                                         OpenCL call will not be able to find
                                         the buffer in relation to a device (it
                                         queries devices for buffers, if they're
                                         not found, XRT is not pleased).
                                         \\
                                         \textbf{Possible fix Ideas:}
                                         \begin{itemize}
                                             \item Eager binary program loading
                                                   as we know we'll only use
                                                   pre"=compiled binaries with
                                                   our FPGAs
                                             \item Lazy OpenCL buffer
                                                   creation/operations, only do
                                                   this after we know XRT will
                                                   be happy i.e. binary loaded
                                                   and good to go
                                         \end{itemize}
                                         \textbf{Work around:} Force start the
                                         device by using a noop kernel, not
                                         ideal and while it works around the
                                         issue on hw/sw emu I'm not too sure how
                                         real hardware will appreciate this.
                                         \\
                                         \\
                                         \textbf{Problem:} Only 1 queue to a
                                         Xilinx FPGA device can exist at once,
                                         if you accidentally generate more than
                                         one XRT will not be happy.
                                         \\
                                         \\
                                         \textbf{Problem:} All kernels require
                                         at least 1 accessor, 0 accessors will
                                         cause a compile error in xocc relating
                                         to no argument being bound to
                                         AXI\_GMEM. Not too sure how many use
                                         cases there are for no accessors in a
                                         kernel but perhaps it shouldn't emit an
                                         error like this.
                                         \\
                                         \\
                                         \textbf{Problem:} Cannot compile for
                                         Xilinx FPGA with -g, this prevents
                                         users using debug mode on the SYCL
                                         runtime not just the kernel.
                                         \\
                                         \textbf{Reason:} I believe this is 
                                         because we're generating a kernel file
                                         with a lot of debug code and trying to
                                         pipe that through xocc which doesn't
                                         really know how to handle all of the
                                         debug information.
                                         \\
                                         \textbf{Possible fix Ideas:}
                                         \begin{itemize}
                                             \item A long shot, but quick fix if
                                                   it worked, add -g to the xocc
                                                   compilation components of the
                                                   sycl-xocc script. Perhaps it
                                                   will realize that the kernel
                                                   may come attached with some
                                                   debug information in this
                                                   case and handle it better. I
                                                   find this unlikely to work,
                                                   but it's low hanging fruit if
                                                   it does\ldots
                                             \item More surefire fix: Do not
                                                   compile the device
                                                   compilation component of SYCL
                                                   with -g, only compile the
                                                   host component with -g and
                                                   remove the -g from being
                                                   pushed onto the device
                                                   compilation. This will create
                                                   a much simpler SPIR-df kernel
                                                   to pass to xocc. Instead -g
                                                   should be applied to the
                                                   xocc compilation and linker
                                                   commands to get the debug
                                                   kernel information. This
                                                   should circumvent any issues
                                                   with debug information
                                                   breaking xocc kernel
                                                   compilation whilst still
                                                   giving kernel debug
                                                   information and SYCL runtime
                                                   debug information. Shouldn't
                                                   be too hard, just requires
                                                   some driver tweaks.
                                         \end{itemize}
                                         \textbf{Problem:} Related to issue:
                                         \#32 mixing structures inside of
                                         kernels can cause ICE's\footnote{
                                         Internal Compiler Error} in one of
                                         xocc's passes: aggressive dead code
                                         elimination (AGDCE). The relevant
                                         minimal triggering SYCL test case for
                                         this is issue\_related/agdce\_ice.cpp.
                                         \\
                                         \textbf{Reason:} Seems to be a problem
                                         relating to address space casting from
                                         a structure that is implemented outside
                                         of a kernel (ergo no address space) and
                                         when you try to index an accessor
                                         containing several passed in
                                         instantiations of the class/struct it
                                         will explode the AGDCE pass inside of
                                         the compiler as it will try to address
                                         space cast.
                                         \\
                                         \textbf{Status:} I am led to believe
                                         it's a bug with xocc/Vivado HLS, so it
                                         appears to be outside of our
                                         jurisdiction, I have forwarded this
                                         issue onto someone on their team but
                                         it's low priority. May take a while for
                                         a fix without some follow up.
                                         \\
                                         \\
                                         \textbf{Problem:} Boost Hana's
                                         times::with\_index in conjunction with
                                         it's overloaded + operator will kill
                                         hw\_emu and very likely hw as it will
                                         not completely optimize and inline with
                                         -03 as you would expect (and as it does
                                         in a non-SYCL -O3 pass). This leaves
                                         some external declarations and calls to
                                         functions but no definitions of the
                                         functions, so partial
                                         optimization/in-lining. Which is a
                                         little odd as the definitions exist
                                         prior to the -O3 pass and other boost
                                         hana functionality is appropriately
                                         inlined.\\
                                         \textbf{Reason:} Current best guess is
                                         that the required index argument passed
                                         into the lambda passed to and invoked
                                         by with\_index is the probable cause.
                                         It seems like it could be another
                                         address space cast related issue. The
                                         minimal test case for this issue is
                                         the example:
                                         boost\_hana\_functor\_arg.cpp inside of
                                         the issue\_related directory.
                                         \begin{code}
                                             \begin{minted}[fontsize=\small]{c++}
cgh.single_task<class array_add>([=]() {
    boost::hana::int_<5>::times.with_index([&](const auto i) {
        a_rw[i+1] = 6;
    });
});
                                             \end{minted}
                                         \end{code}
                                         So to highlight the issue, In the
                                         example there is an variable passed
                                         into the lambda from an externally
                                         defined function, this then gets used
                                         with the + operator. This + operator is
                                         overloaded inside of Boost Hana to
                                         support compile time usage. This
                                         snippet of code should be unrolled and
                                         inlined removing all of the Boost Hana
                                         related functionality. This doesn't
                                         happen and it seems to be because the
                                         argument passed into the function and
                                         being incremented and used with the
                                         value 1 will trigger an address space
                                         cast which I think will prevent the
                                         appropriate and required optimizations.
                                         \\
                                         This is an an assumption though, based
                                         on the fact that the below code works
                                         fine:
                                         \begin{code}
                                             \begin{minted}[fontsize=\small]{c++}
cgh.single_task<class array_add>([=]() {
    int i = 0;
    boost::hana::int_<N>::times([&] {
        a_rw[i+0] = 6;
        ++i;
    });
});
                                             \end{minted}
                                         \end{code}
                                         The index variable and the random
                                         constant variable now exist in the same
                                         address space and the world all seems
                                         to be fine as far as the compiler is
                                         concerned.
                                         \\
                                         \\
                                         Some of these ``problems'' are
                                         peculiarities in our FPGA compilation
                                         pipeline and non-standard OpenCL
                                         implementation and may not necessarily
                                         be ``problems''.
\end{otherlanguage}
