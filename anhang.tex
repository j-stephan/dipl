\chapter{Quelltexte}

\section{VHDL-Quelltexte}\label{anhang:source:vhdl}

\begin{code}
    \begin{minted}[fontsize=\small]{vhdl}
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY ff2 IS
    PORT (
        clk : IN    std_logic;
        d0  : IN    std_logic;
        d1  : IN    std_logic;
        res : IN    std_logic;
        q0  : OUT   std_logic;
        q1  : OUT   std_logic
    );
END ff2 ;

ARCHITECTURE beh OF ff2 IS
    SIGNAL q0_s, q1_s : std_logic;
BEGIN
    
    reg: PROCESS (clk, res)
    BEGIN
        IF res = '1' THEN
            q0_s <= '0';
            q1_s <= '0';
        ELSIF clk'event AND clk = '1' THEN
            q0_s <= d0;
            q1_s <= d1;
        END IF;
    END PROCESS reg;

    q0 <= q0_s AFTER 2 ns;
    q1 <= q1_s AFTER 2 ns;

END beh;
    \end{minted}
    \caption{VHDL-Quelltext eines 2-Bit-Flipflops \cite[siehe][39]{kesel2013}}
\end{code}

\begin{code}
    \begin{minted}[fontsize=\small]{vhdl}
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY mux2 IS
    PORT (
        a1  : IN    std_logic;
        a2  : IN    std_logic;
        b1  : IN    std_logic;
        b2  : IN    std_logic;
        sel : IN    std_logic;
        o1  : OUT   std_logic;
        o2  : OUT   std_logic
    );
END mux2 ;

ARCHITECTURE beh OF mux2 IS
BEGIN

    mux: PROCESS (a1, a2, b1, b2, sel)
    BEGIN
        IF sel = '1' THEN
            o1 <= a1 after 3 ns;
            o2 <= a2 after 3 ns;
        ELSE
            o1 <= b1 after 4 ns;
            o2 <= b2 after 4 ns;
        END IF;
    END PROCESS mux;

END beh;
    \end{minted}
    \caption{VHDL-Quelltext eines 2-Bit-Multiplexers \cite[siehe][39--40]{kesel2013}}
\end{code}

\section{C++"=Quelltexte}
\label{anhang:source:cpp}

\subsection{Implementierung des TaskKernelSycl-Konstruktors}
\label{anhang:source:cpp:taskkernelsyclkonst}

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
template <typename TWorkDiv>
TaskKernelSycl(TWorkDiv&& workDiv,
               const TKernelFnObj& kernelFnObj,
               const TArgs&... args)
: workdiv::WorkDivMembers<TDim, TIdx>(std::forward<TWorkDiv>(workDiv))
, m_kernelFnObj{kernelFnObj}
, m_args{args...}
{
}
    \end{minted}
    \caption{Implementierung des Konstruktors der \texttt{TaskKernelSycl}"=Klasse}
\end{code}

\subsection{Implementierung des SYCL-Puffer-Wrappers}
\label{anhang:source:cpp:bufferwrapper}

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
namespace alpaka
{
    namespace mem
    {
        namespace buf
        {
            namespace sycl
            {
                namespace detail
                {
                    template <typename TBuf>
                    struct buffer_wrapper
                    {
                        using buf_type = TBuf;
                        using value_type = typename buf_type::value_type;
                        using is_alpaka_sycl_buffer_wrapper = bool;

                        buffer_wrapper(TBuf wrapped_buf) noexcept
                        : buf{wrapped_buf}
                        , dummy{std::aligned_alloc(alignof(value_type),
                                                   sizeof(std::size_t)),
                                [](void* ptr) { std::free(ptr); }}
                        {
                        }

                        operator value_type*() noexcept
                        {
                            return reinterpret_cast<value_type*>(dummy.get());
                        }

                        operator const value_type*() const noexcept
                        {
                            return reinterpret_cast<const value_type*>(
                                                                dummy.get());
                        }

                        TBuf buf;
                        std::shared_ptr<void> dummy;
                    };
                }
            }
        }
    }
}
    \end{minted}
    \caption{Implementierung des SYCL-Puffer-Wrappers}
\end{code}

\chapter{Fehlerberichte und Korrekturen}
\label{anhang:fehler}

\section{Fehlerberichte und Korrekturen für die Xilinx-OpenCL-Laufzeitumgebung}
\label{anhang:fehler:xrt}

\section{Fehlerberichte und Korrekturen für den Xilinx-SYCL-Compiler}
\label{anhang:fehler:xilinx}

\section{Fehlerberichte und Korrekturen für den Intel-SYCL-Compiler}
\label{anhang:fehler:intel}

\section{Fehlerberichte und Korrekturen für den ComputeCpp-SYCL-Compiler}
\label{anhang:fehler:computecpp}

\chapter{Online-Diskussionen}\label{anhang:diskussionen}

\section{Diskussionen mit dem SYCL-Spezifikationskomitee}
\label{anhang:diskussionen:syclspec}

\subsection{Implicit accessor-to-pointer casts}
\label{anhang:diskussion:syclspec:implicitaccessor}

Original: \url{https://github.com/KhronosGroup/SYCL-Docs/issues/11}, zuletzt
abgerufen am 06. November 2019.

\begin{otherlanguage}{english}
    \paragraph{Jan Stephan} This is a duplicate of triSYCL/triSYCL\#247, moving
                            the discussion here.
                            \subparagraph{The Problem} The SYCL specification
                            (3.5.2.1) says the following:
                            \begin{quote}
                                Within kernels, accessors can be implicitly cast
                                to C++ pointer types. The pointer types will
                                contain a compile-time deduced address space.
                                So, for example, if an accessor to global memory
                                is cast to a C++ pointer, the C++ pointer type
                                will have a global address space attribute
                                attached to it. The address space attribute will
                                be compile-time propagated to other pointer
                                values when one pointer is initialized to
                                another pointer value using a defined mechanism.
                            \end{quote}
                            This is not reflected in \texttt{accessor}'s
                            interface and none of the publicly available
                            implementations support this.
                            \subparagraph{Example} $~$ \\
                            \begin{code}
                                \begin{minted}[fontsize=\small]{c++}
void vec_add(const int* a, const int* b, int* c, std::size_t size);

queue.submit([&](cl::sycl::handler& cgh)
{
    auto a = a_d.get_access<cl::sycl::access::mode::read>(cgh);
    auto b = b_d.get_access<cl::sycl::access::mode::read>(cgh);
    auto c = c_d.get_access<cl::sycl::access::mode::discard_write(cgh);

    cgh.single_task<class vector_add>([=]()
    {
        // no known conversion from accessor to const int*
        vec_add(a, b, c, 1024);
    });
});
                                \end{minted}
                            \end{code}
                            \subparagraph{Use case}
                            Libraries such as Alpaka or HPX provide abstraction
                            layers over competing compute APIs such as CUDA.
                            Unfortunately their API works with raw pointers in
                            their abstract kernels. In order to implement a SYCL
                            backend the \texttt{accessor} has to be explicitly
                            transformed into a pointer right now (by going
                            through \texttt{multi\_ptr}). Being able to do this
                            implicitly would be a lot easier.
                            \subparagraph{Possible solutions}
                            \begin{enumerate}
                                \item Remove the above wording and rely on
                                      \texttt{multi\_ptr}'s conversion instead.
                                \item Allow \texttt{accessor} to be implicitly
                                      cast as well.
                            \end{enumerate}
    \paragraph{Ronan Keryell (Xilinx)} The working group is looking at this
                                       internally.
    \paragraph{Ruymán Reyes Castro (Codeplay)} Internal issue tracker: \url{https://gitlab.khronos.org/sycl/Specification/issues/258},
                                               currently assigned to Codeplay.
    \paragraph{Ruymán Reyes Castro} Decision has been to go for option 1, MR up
                                    in: \#44
    \paragraph{Gordon Brown (Codeplay)} SYCL working group: The above merge
                                        request has been approved so we can
                                        close this now.
\end{otherlanguage}

\subsection{Why is there no way to allocate local memory inside a ND-kernel
            (parallel\_for)?}\label{anhang:diskussionen:syclspec:staticshared}

Original: \url{https://github.com/KhronosGroup/SYCL-Docs/issues/20}, zuletzt
abgerufen am 06. November 2019.

\begin{otherlanguage}{english}
    \paragraph{Jan Stephan} I know this is possible using the hierarchical
                            \texttt{parallel\_for} invoke, but we can't do it
                            with the \texttt{nd\_item} version despite being
                            able to specify the group size. OpenCL allows this
                            (AFAIK), SYCL's competitors do, too, so why not
                            allow it in SYCL? I suppose there must be a reason
                            for leaving it out.
    \paragraph{Victor Lomuller (Codeplay)} The main reason is the host device.
                            If your compiler is not SYCL aware, you need to be
                            able to preallocate this memory before calling the
                            functor, which is not trivial without compiler
                            support.
    \paragraph{Jan Stephan} Wouldn't this be solvable by doing the inverse of
                            the hierarchical case? I.e. everything is
                            \texttt{private} by default if declared inside the
                            kernel, unless embedded with something like
                            \texttt{cl::sycl::local\_memory}.
    \paragraph{Victor Lomuller} It does not address the compiler support
                                problem. You still need to preallocate memory
                                before calling the functor, but without compiler
                                support, you cannot know the amount of memory
                                you need nor where to place the pointer to that
                                memory (the stack frame does not exist yet).
    \paragraph{Ronan Keryell (Xilinx)} which SYCL competitor can run on CPU
                              without a specific compiler? This allows for
                              example to use HellGrind \& ThreadSanitizer with
                              plain GCC or Clang to debug a SYCL program just by
                              running it on my laptop. I find this an amazing
                              feature of SYCL...
    \paragraph{Gordon Brown (Codeplay)} SYCL working group: We agree this would
                                        be a useful feature to have, we are
                                        investigating how to potentially support
                                        this internally.
\end{otherlanguage}

\newpage
\subsection{How to extract address space from raw pointers?}
\label{anhang:diskussionen:syclspec:addressspace}

Original: \url{https://github.com/KhronosGroup/SYCL-Docs/issues/21}, zuletzt
abgerufen am 06. November 2019.

\begin{otherlanguage}{english}
    \paragraph{Jan Stephan} Imagine a device-side function with the following
                            signature:
                            \begin{code}
                                \begin{minted}[fontsize=\small]{c++}
void foo(int* vec);
                                \end{minted}
                            \end{code}
                            I don't know if \texttt{vec} comes from global,
                            local, constant or private memory. However, inside
                            \texttt{foo} I'd like to do something to
                            \texttt{vec} which requires me to know the address
                            space of the pointer, e.g. a
                            \texttt{cl::sycl::atomic\_fetch\_add}. How do I tell
                            the \texttt{multi\_ptr} / \texttt{atomic} inside
                            \texttt{foo} which address space is needed? Simply
                            using a \texttt{global\_ptr} will break if
                            \texttt{vec} actually resides in local memory. Using
                            \texttt{multi\_ptr} will fail because the address
                            space template parameter is missing. Creating an
                            \texttt{atomic} by passing \texttt{vec} to its
                            constructor will fail because \texttt{vec} isn't a
                            \texttt{multi\_ptr}. Using
                            \texttt{atomic\_fetch\_add} on \texttt{vec} will
                            fail because \texttt{vec} isn't an \texttt{atomic}
                            type.
                            \\
                            Some implementations (like ComputeCpp) internally
                            use \texttt{\_\_global} to annotate the pointer
                            during device compilation. But even if there was a
                            way to write something like\\
                            \texttt{void foo(\_\_global int* vec)}
                            (there isn't as far as I know, ComputeCpp complains
                            if I do this) this would be a bad idea because the
                            address space attributes are implementation-defined.
                            \\
                            Why do we need this? Sadly, there are libraries /
                            frameworks out there that pass around raw pointers
                            but where a SYCL backend is planned / worked on.
                            \\
                            Edit: I also tried to overload \texttt{foo} with
                            \texttt{global\_ptr}, \texttt{local\_ptr} etc.
                            directly. This will fail because the call is
                            ambigous.
    \paragraph{Ronan Keryell (Xilinx)} Interestingly, Intel is trying hard to
                                       hide what you are asking for:\\
                                       \texttt{intel/llvm\#348}\footnote{Verweis
                                       auf Änderung des Intel-SYCL-Compilers, 
                                       J.S.}. Can you imagine an API that could
                                       be added to the standard?
    \paragraph{Jan Stephan} An easy solution that doesn't require an API change
                            would be to correctly deduce the overloads, i.e.
                            \texttt{foo(global\_ptr)}, \texttt{foo(local\_ptr)}
                            and so on. This is not very intuitive, though, and
                            might break user APIs.
                            \\
                            From the programmer's point of view it would be
                            preferable to allow \texttt{multi\_ptr}
                            construction on raw pointers without having to
                            specify the address space. The compiler should be
                            able to figure this out by itself since it knows
                            about the address spaces anyway.
                            \\
                            On the other hand it should raise an error if the
                            programmer tries to assign a raw pointer in local
                            space to a \texttt{global\_ptr}. Currently this
                            doesn't happen, both the Intel and ComputeCpp
                            compiler will happily compile if I pass the same
                            pointer to \texttt{global\_ptr}'s and
                            \texttt{local\_ptr}'s constructor.
                            \\
                            Admittedly I haven't given this much thought yet (I
                            only encountered the problem on Wednesday), I'll try
                            to think this through on the weekend.
    \paragraph{Jan Stephan} The weekend has passed... Apart from the solutions
                            above the best I could come up with is something
                            like \texttt{cl::sycl::pointer\_traits} to be added
                            to the specification. The interface would look
                            something along the lines of
                            \begin{code}
                                \begin{minted}[fontsize=\small]{c++}
template <typename Ptr>
struct pointer_traits
{
    static_assert(is_raw_ptr_type(Ptr), "Ptr needs to be a raw pointer type");
    using pointer_t = /* implementation-defined */ Ptr;
    using address_space = /* implementation-defined */;
    // maybe add other traits here
};
                                \end{minted}
                            \end{code}
                            Since the compiler needs to figure out the address
                            space on its own anyway (if I understand Section 6.8
                            correctly), it would fill out the
                            \texttt{implementation-defined} parts. A programmer
                            could then use SFINAE or \texttt{if constexpr} to
                            adapt to the different address spaces.
                            \\
                            This is basically the problem \texttt{multi\_ptr}
                            tries to solve, it already encapsulates the
                            functionality above. However, \texttt{multi\_ptr}
                            requires the user to specify the address space
                            before using it. This makes sense because we can
                            request a \texttt{multi\_ptr} from a buffer
                            accessor, a local accessor, and so on and the
                            \texttt{multi\_pt}r data structure has to know about
                            its address space. It also renders us unable to
                            construct it from a pointer we don't know the
                            address space of.
                            \\
                            So my straight-forward resolution still is to remove
                            the requirement to specify the address space for the
                            \texttt{multi\_ptr} type. Instead the compiler needs
                            to figure out the correct value for the
                            \texttt{address\_space} member of
                            \texttt{multi\_ptr} (or the \texttt{Space} template
                            parameter). If this is not an option because of
                            implications I'm not aware of (and I'm sure there
                            are plenty) I'd shoot for the
                            \texttt{pointer\_traits} option.
    \paragraph{Ronan Keryell} \begin{quote}
                                Since the compiler needs to figure out the
                                address space on its own anyway (if I understand
                                Section 6.8 correctly), it would fill out the
                                implementation-defined parts. A programmer could
                                then use SFINAE or \texttt{if constexpr} to
                                adapt to the different address spaces.
                              \end{quote}
                              The problem is that this address space resolution
                              can be done in LLVM or even in the SPIR-V backend
                              or whatever... So you might not have this
                              information inside Clang as a type trait... :-(
                              \\
                              \texttt{multi\_ptr} was designed:
                              \begin{itemize}
                                  \item to avoid requiring this kind of
                                        address-space inference by avoiding
                                        using raw pointers. Of course this means
                                        passing around the \texttt{multi\_ptr}
                                        type. But with \texttt{auto} nowadays it
                                        is easier;
                                  \item to provide a way to interoperate with
                                        existing OpenCL C kernel code. But since
                                        there is no type inference in OpenCL C
                                        either, you have to do an explicit
                                        dispatch yourself from the
                                        \texttt{multi\_ptr} to call an OpenCL
                                        function with different version and
                                        different names for each possible
                                        address-space...
                              \end{itemize}
    \paragraph{Jan Stephan} \begin{quote}
                                The problem is that this address space
                                resolution can be done in LLVM or even in the
                                SPIR-V backend or whatever... So you might not
                                have this information inside Clang as a type
                                trait... :-(
                            \end{quote}
                            I have to admit that my knowledge about compiler
                            construction is a bit limited. But the backends will
                            have to look up this information, too - why can't
                            the frontend do the same?
                            \begin{quote}
                                to avoid requiring this kind of address-space
                                inference by avoiding using raw pointers. Of
                                course this means passing around the
                                multi\_ptr type. But with auto nowadays it is
                                easier;
                            \end{quote}
                            While I can understand this intent with regard to
                            new code I believe this is an oversight if we
                            consider legacy code bases. If those have a raw
                            pointer API the design of \texttt{multi\_ptr} or
                            the lack of a feature to otherwise extract the
                            address space becomes a major obstacle.
\end{otherlanguage}

\section{Diskussionen mit Xilinx-Angestellten}

\section{Diskussionen mit Codeplay-Angestellten}
