\chapter{Die Alpaka-Bibliothek}\label{alpaka}

Dieses Kapitel führt in die Alpaka"=Bibliothek ein. Wie im vorherigen
SYCL"=Kapitel wird der grundlegende Aufbau eines Alpaka"=Programms anhand des
AXPY"=Beispiels dargestellt. Ein weiterer Abschnitt ist den darauf aufbauenden,
erweiterten Konzepten, wie etwa der Hardware"=Abstraktion, gewidmet.

\section{Überblick}\label{alpaka:ueberblick}

Alpaka (Eigenschreibweise: \textit{alpaka}) steht für
\textit{Abstraction Library for Parallel Kernel Acceleration} und wurde
ursprünglich von Benjamin Worpitz im Rahmen seiner Masterarbeit entwickelt
\cite[vgl.][]{worpitz2015}. Mittlerweile wird die Entwicklung durch
die Gruppe \textit{Computergestützte Strahlenphysik} des
\textit{Instituts für Strahlenphysik} am
\textit{Helmholtz"=Zentrum Dresden"=Rossendorf} fortgeführt.

Die Alpaka"=Bibliothek definiert eine abstrakte C++"=Schnittstelle, mit deren
Hilfe parallele Programme geschrieben werden können. Im Hintergrund wird Alpaka
auf hersteller- oder hardware"=spezifische Schnittstellen, wie CUDA oder OpenMP,
-- im Folgenden als \textit{Backend} bezeichnet -- abgebildet. Schematisch ist
dies in Abbildung~\ref{alpaka:ueberblick:schema} dargestellt. Alpaka ist somit
ein einheitliches Paket, das die abstrakte Schnittstelle nach außen und die
konkrete Implementierung vereinigt. Damit unterscheidet sich die Bibliothek von
ähnlichen Ansätzen wie OpenCL oder SYCL, die ebenfalls eine abstrakte
Schnittstelle definieren, die Implementierung jedoch den Hardware- und
Software"=Herstellern überlassen.

\begin{figure}
    \centering
    \begin{tikzpicture}
        \draw [rounded corners, fill = HKS33!70] (2.5, 3.5) rectangle (16, 5)
              node [pos = 0.5, align = center] {\color{white}\textbf{Alpaka}};

        \draw [rounded corners, fill = HKS44!70] (0, 1.75) rectangle (2.25, 3.25)
              node [pos = 0.5, align = center] {\color{white}\textbf{Backends}};

        \draw [rounded corners, fill = HKS44!70] (2.5, 1.75) rectangle (4.75, 3.25)
              node [pos = 0.5, align = center] {\color{white}\textbf{Sequentiell}};
        \draw [rounded corners, fill = HKS44!70] (4.85, 1.75) rectangle (7.1, 3.25)
               node [pos = 0.5, align = center] {\color{white}\textbf{OpenMP}};
        \draw [rounded corners, fill = HKS44!70] (7.2, 1.75) rectangle (9.45, 3.25)
              node [pos = 0.5, align = center] {\color{white}\textbf{Boost}\\
                                                \color{white}\textbf{Fiber}};
        \draw [rounded corners, fill = HKS44!70] (9.55, 1.75) rectangle (11.8, 3.25)
              node [pos = 0.5, align = center] {\color{white}\textbf{Intel}\\
                                                \color{white}\textbf{TBB}};
        \draw [rounded corners, fill = HKS44!70] (11.9, 1.75) rectangle (13.9, 3.25)
              node [pos = 0.5, align = center] {\color{white}\textbf{CUDA}};
        \draw [rounded corners, fill = HKS44!70] (14, 1.75) rectangle (16, 3.25)
              node [pos = 0.5, align = center] {\color{white}\textbf{HIP}};

        \draw [rounded corners, fill = HKS41!70] (0, 0) rectangle (2.25, 1.5)
              node [pos = 0.5, align = center] {\color{white}\textbf{Hardware}};
        \draw [rounded corners, fill = HKS41!70] (2.5, 0) rectangle (11.8, 1.5)
              node [pos = 0.5, align = center] {\color{white}\textbf{x86, Xeon Phi, ARM, \ldots}};
        \draw [rounded corners, fill = HKS41!70] (11.9, 0) rectangle (14.95, 1.5)
              node [pos = 0.5, align = center] {\color{white}\textbf{NVIDIA}\\
                                                \color{white}\textbf{GPU}};
        \draw [rounded corners, fill = HKS41!70] (15.05, 0) rectangle (16, 1.5)
              node [pos = 0.5, align = center] {\color{white}\textbf{AMD}\\
                                                \color{white}\textbf{GPU}};
    \end{tikzpicture}
    \caption{Schematischer Aufbau der Alpaka-Bibliothek}
    \label{alpaka:ueberblick:schema}
\end{figure}

Wie bei SYCL sind die Quelltexte für \textit{Host} und \textit{Device} nicht
voneinander getrennt. Die Abbildung auf ein oder mehrere Backends erfolgt zur
Compile"=Zeit durch Template"=Metaprogrammierung, wodurch ein
Abstraktions"=Overhead zur Laufzeit vermieden wird.

Ähnlich wie SYCL bietet auch Alpaka ein beschleunigerunabhängiges Backend, das
sich prinzipiell mit jedem modernen C++"=Compiler kompilieren lässt. Dieses
wird in der Alpaka"=Terminologie \texttt{CpuSerial} genannt und führt jeden
Befehl sequentiell aus. Während der Kernel"=Ausführung existiert also keinerlei
Parallelität.

\subsection{AXPY und Alpaka}\label{alpaka:ueberblick:axpy}

Zum Zwecke der einfachen Vergleichbarkeit der von SYCL und Alpaka gebotenen
Programmiermodelle wird das im vorigen Kapitel verwendete AXPY"=Beispiel der
BLAS"=Bibliothek hier erneut aufgegriffen. Strukturell ähneln sich SYCL und
Alpaka recht stark, wie der
Platzhalter"=Quelltext~\ref{alpaka:ueberblick:axpy:struktur} zeigt. Wie im
vorigen Kapitel wird auch dieser Quelltext nach und nach mit Inhalt gefüllt.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
#include <cstdlib>

#include <alpaka/alpaka.hpp>

auto main() -> int
{
    // Beschleunigerwahl und Befehlswarteschlange

    // Speicherreservierung und -initialisierung

    // Kerneldefinition und -ausführung

    // Synchronisierung

    return EXIT_SUCCESS;
}
    \end{minted}
    \caption{Struktur eines Alpaka-Programms}
    \label{alpaka:ueberblick:axpy:struktur}
\end{code}

\subsubsection{Beschleunigerwahl und Befehlswarteschlange}
\label{alpaka:ueberblick:axpy:queue}

Die Auswahl des Beschleunigers erfolgt bei Alpaka bereits zur Compile"=Zeit. Der
Programmierer muss also im Vorfeld eine Entscheidung darüber treffen, auf
welchen Systemen sein Programm lauffähig sein soll. Dazu wählt der Programmierer
zunächst einen der im Umfang von Alpaka vorhandenen beschleunigerspezifischen
Datentypen aus und definiert, welche Datentypen für die Angabe der im Programm
verwendeten Dimensionen und Indizes verwendet werden sollen. Dieser Vorgang ist
in Quelltext~\ref{alpaka:ueberblick:axpy:queue:acc_src} dargestellt.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
// Definition für ein eindimensionales Problem
using Dim = alpaka::dim::DimInt<1u>;
using Idx = std::size_t;
using Acc = alpaka::acc::AccGpuCudaRt<Dim, Idx>;
    \end{minted}
    \caption{Auswahl der in Alpaka vorhandenen NVIDIA"=CUDA"=Implementierung}
    \label{alpaka:ueberblick:axpy:queue:acc_src}
\end{code}

In der Folge wird der definierte Typ \texttt{Acc} als Parameter für weitere
Datentypen verwendet. Bei letzteren handelt es sich um die Klassen für die
Verwaltung konkreter Beschleuniger. Diese sind in Alpaka als abstrakte
Template"=Klassen mit einer aus Sicht des Programmierers einheitlichen
Schnittstelle vorhanden. Durch den \texttt{Acc}"=Parameter werden diese Klassen
zur Compile"=Zeit spezialisiert und enthalten die für die jeweilige Hardware
korrekten Code"=Pfade. Dadurch ist der Gesamtquelltext mit wenig Aufwand
portabel, da ein einfacher Austausch des \texttt{Acc}"=Parameters passenden Code
für andere Hardware"=Architekturen generieren kann. Neben der Auswahl des
Beschleunigers ist außerdem die Auswahl eines Datentypen für den
\textit{Host} erforderlich, der später die Verwaltung einiger
\textit{Host}"=seitiger Befehle übernehmen wird. Der
Quelltext~\ref{alpaka:ueberblick:axpy:queue:dev_src} zeigt die Verwendung der
genannten Strukturen für die oben gewünschte CUDA"=Implementierung.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
using DevAcc = alpaka::dev::Dev<Acc>;
using PltfAcc = alpaka::pltf::Pltf<Acc>;
using PltfHost = alpaka::pltf::PltfCpu;
    \end{minted}
    \caption{Spezialisierung abstrakter Alpaka"=Klassen}
    \label{alpaka:ueberblick:axpy:queue:dev_src}
\end{code}

In einem weiteren Schritt muss die Befehlswarteschlange initialisiert werden.
Diese dient -- wie auch in SYCL -- als Verbindungselement zwischen \textit{Host}
und \textit{Device}. Alle das \textit{Device} betreffenden Befehle werden in
ihr eingereiht. Anders als in SYCL gibt es in Alpaka die Möglichkeit, eine zum
\textit{Host} synchrone Warteschlange zu verwenden -- der \textit{Host} wird von
der Warteschlange also so lange blockiert, bis die Verarbeitung auf dem
\textit{Device} abgeschlossen ist. In diesem Beispiel ist dies jedoch nicht
notwendig, weshalb eine asynchrone Warteschlange verwendet wird, wie
Quelltext~\ref{alpaka:ueberblick:axpy:queue:queue_src} zeigt. Wie man schnell
erkennt, existiert kein \texttt{Acc}"=Parameter für eine Alpaka"=\texttt{queue}
-- der Programmierer muss diese also ebenfalls selbst passend wählen.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
using Queue = alpaka::queue::QueueCudaRtNonBlocking;
    \end{minted}
    \caption{Auswahl der Alpaka"=Befehlswarteschlange}
    \label{alpaka:ueberblick:axpy:queue:queue_src}
\end{code}

Im letzten Schritt werden die oben definierten Datentypen instanziiert oder als
Parameter für die Instanziierung weiterer Datenstrukturen verwendet. Mit dem
in Quelltext~\ref{alpaka:ueberblick:axpy:queue:inst_src} gezeigten Vorgehen ist
der erste Abschnitt eines Alpaka"=Programms beendet.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
// instanziiere Host und Device
auto devHost = alpaka::pltf::getDevByIdx<PltfHost>(0u);
auto devAcc = alpaka::pltf::getDevByIdx<PltfAcc>(0u);

// instanziiere Befehlswarteschlange
auto queue = Queue{devAcc};
    \end{minted}
    \caption{Instanziierung der Alpaka"=Datentypen}
    \label{alpaka:ueberblick:axpy:queue:inst_src}
\end{code}

\subsubsection{Speicherreservierung und -initialisierung}
\label{alpaka:ueberblick:axpy:buffer}

Die für die AXPY"=Operation nötigen Vektoren müssen zunächst im Speicher
angelegt und initialisiert werden. Dies erfolgt in drei Stufen:

\begin{enumerate}
    \item Reserviere gleich große Speicherbereiche sowohl auf dem \textit{Host}
          als auch auf dem \textit{Device}.
    \item Initialisiere den \textit{Host}"=Speicher mit den gewünschten Werten.
    \item Kopiere die initialisierten Werte auf das \textit{Device}.
\end{enumerate}

Ähnlich wie bei SYCL werden Speicherbereiche in Alpaka durch Puffer dargestellt,
die die reinen Zeiger kapseln. Im Gegensatz zu SYCL sind die Puffer auf dem Host
und Device jedoch voneinander unabhängig. Es ist also nicht möglich, einen
gemeinsamen Puffer zu erzeugen, der die notwendigen Kopien für den Programmierer
unsichtbar im Hintergrund durchführt, wie dies in
Abschnitt~\ref{sycl:ueberblick:axpy:buffer} für SYCL demonstriert wurde.

Für die Erzeugung von Puffern ist es zunächst nötig, die gewünschte Größe des
Puffers durch eine spezielle Datenstruktur zu definieren, wie der
Quelltext~\ref{alpaka:ueberblick:axpy:buffer:extent_src} zeigt.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
auto extent = alpaka::vec::Vec<Dim, Idx>{numElements};
    \end{minted}
    \caption{Definition eines Größenvektors mit Alpaka}
    \label{alpaka:ueberblick:axpy:buffer:extent_src}
\end{code}

In der Folge kann die Größe verwendet werden, um den Speicher sowohl auf dem
\textit{Host} als auch auf dem \textit{Device} zu reseriveren. Dies ist in
Quelltext~\ref{alpaka:ueberblick:axpy:buffer:alloc} dargestellt.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
auto hostBufX = alpaka::mem::buf::alloc<int, Idx>(devHost, extent);
auto hostBufY = alpaka::mem::buf::alloc<int, Idx>(devHost, extent);

auto devBufX = alpaka::mem::buf::alloc<int, Idx>(devAcc, extent);
auto devBufY = alpaka::mem::buf::alloc<int, Idx>(devAcc, extent);
    \end{minted}
    \caption{Speicherallokation mit Alpaka}
    \label{alpaka:ueberblick:axpy:buffer:alloc}
\end{code}

Die in Quelltext~\ref{alpaka:ueberblick:axpy:buffer:init} durchgeführte
Initialisierung erfolgt über die von den \textit{Host}"=Puffern gekapselten
Zeiger, auf die man bei Alpaka direkt zugreifen kann.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
auto hostPtrX = alpaka::mem::view::getPtrNative(hostBufX);
auto hostPtrY = alpaka::mem::view::getPtrNative(hostBufY);

for(auto i = 0; i < numElements; ++i)
{
    hostPtrX[i] = /* ... */;
    hostPtrY[i] = /* ... */;
}
    \end{minted}
    \caption{Initialisierung eines Alpaka-Puffers}
    \label{alpaka:ueberblick:axpy:buffer:init}
\end{code}

Im letzten Schritt (siehe Quelltext~\ref{alpaka:ueberblick:axpy:buffer:copy})
müssen die Daten vom \textit{Host} auf das \textit{Device} kopiert werden. Dazu
werden Kopieroperationen in der oben angelegten Warteschlange eingereiht.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
alpaka::mem::view::copy(queue, devBufX, hostBufX, extent);
alpaka::mem::view::copy(queue, devBufY, hostBufY, extent);
    \end{minted}
    \caption{Kopie der initialisierten Daten mit Alpaka}
    \label{alpaka:ueberblick:axpy:buffer:copy}
\end{code}

\subsubsection{Kerneldefinition und -ausführung}
\label{alpaka:ueberblick:axpy:kernel}

Um die parallelen Eigenschaften der Ziel"=Hardware nutzen zu können, erfordert
Alpaka eine Information, wie das zu bearbeitende Problem auf die
Hardware"=Ressourcen aufgeteilt werden soll. Dazu kann der Programmierer eine
in Alpaka vorhandene Funktion nutzen, die eine gute Aufteilung schätzen kann,
oder selbst Definitionen für die Größe des \textit{Grids}, die Zahl der
\textit{Threads} sowie der \textit{Elements} pro \textit{Thread} angeben. Die
Aufteilung in \textit{Grid}, \textit{Threads} und \textit{Elements} ist ein
Konzept der in Alpaka verwendeten Hardware"=Abstraktion und wird detailliert in
Abschnitt~\ref{alpaka:konzepte:abstraktion} behandelt. Für dieses Beispiel
genügt die Verwendung der Schätzfunktion, wie sie in
Quelltext~\ref{alpaka:ueberblick:axpy:kernel:workdiv} gezeigt wird.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
auto workDiv = alpaka::workdiv::getValidWorkDiv<Acc>(
                devAcc,                 // für welches Device?
                extent,                 // für welche Problemgröße?
                static_cast<Idx>(1u));  // wie viele Elemente pro Thread?
    \end{minted}
    \caption{Arbeitsaufteilung durch Alpaka"=Schätzfunktion}
    \label{alpaka:ueberblick:axpy:kernel:workdiv}
\end{code}

Alpaka"=Kernel werden in Form von C++"=Funktoren -- das heißt Strukturen mit
einem überladenen \texttt{()}"=Operator -- definiert. Der \texttt{()}"=Operator
wird mit einem speziellen Funktionsattribut versehen (\texttt{ALPAKA\_FN\_ACC}),
der im Hintergrund dafür sorgt, dass diese Funktion für das \textit{Device} und
nicht den \textit{Host} kompiliert wird.

Als Parameter nimmt der Kernel zunächst die oben definierte
\texttt{devAcc}"=Instanz entgegen. Dies ist nötig, um von dieser Struktur
gekapselte \textit{device}"=seitige Funktionen im Kernel nutzen zu können.
Daneben ist nur die Angabe der eigentlichen Funktionsparameter erforderlich,
in diesem Fall also die für den AXPY"=Algorithmus nötige Konstante \texttt{a}
sowie die Ein- bzw. Ausgangsvektoren. Wie auf dem \textit{Host} erfolgt auch auf
dem \textit{Device} der Zugriff auf die Speicherbereiche durch reine Zeiger.

Innerhalb des Kernels wird ein Index"=Raum aufgespannt (eine genaue Erläuterung
dieses Prinzips folgt in Abschnitt~\ref{alpaka:konzepte:abstraktion}), in dem
jeder ausführenden Einheit des Beschleunigers ein eindeutiger Index sowie zu
bearbeitende Elemente zugeordnet werden. Über in Alpaka vorhandene Funktionen
ist eine Orientierung innerhalb des Index"=Raums möglich, wodurch die
AXPY"=Funktion auf alle Vektor"=Elemente angewendet werden kann.

Die gesamte Kernel"=Definition ist in
Quelltext~\ref{alpaka:ueberblick:axpy:kernel:kernel_src} dargestellt.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
struct AxpyKernel
{
    template <typename TAcc, typename TIdx>
    ALPAKA_FN_ACC auto operator()(
        const TAcc& acc,
        const TIdx& numElements,
        const int a,
        const int* X,
        int* Y
        ) const -> void
    {
        auto gridThreadIdx = alpaka::idx::getIdx<
                                    alpaka::Grid, alpaka::Threads>(acc)[0u];
        auto threadElemExtent = alpaka::workdiv::getWorkDiv<
                                    alpaka::Thread, alpaka::Elems>(acc)[0u];
        auto threadFirstElemIdx = gridThreadIdx * threadElemExtent;

        if(threadFirstElemIdx < numElements)
        {
            auto threadLastElemIdx = threadFirstElemIdx + threadElemExtent;
            
            for(auto i = threadFirstElemIdx; i < threadLastElemIdx; ++i)
            {
                Y[i] = a * X[i] + Y[i];
            }
        }
    }
};
    \end{minted}
    \caption{Kernel"=Definition in Alpaka}
    \label{alpaka:ueberblick:axpy:kernel:kernel_src}
\end{code}

Der so definierte Kernel wird im nächsten Schritt einem \textit{Task}
zugeordnet. Ein \textit{Task} ist prinzipiell mit einer \textit{command group}
in SYCL vergleichbar und umfasst neben der Kernel"=Definition die gewünschte
Aufteilung der Arbeit sowie die konkreten Ein- und Ausgabeparameter für eine
Kernel"=Ausführung. Ein Alpaka"=\textit{Task} wird einer Alpaka"=\textit{Queue}
übergeben und von dieser auf dem \textit{Device} zur Ausführung gebracht.

Der gesamte Prozess ist in Quelltext~\ref{alpaka:ueberblick:axpy:kernel:task}
gezeigt.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
auto taskKernel = alpaka::kernel::createTaskKernel<Acc>(
                    workDiv,
                    AxpyKernel{},
                    numElements,
                    a,
                    alpaka::mem::view::getPtrNative(devBufX),
                    alpaka::mem::view::getPtrNative(devBufY));

alpaka::queue::enqueue(queue, taskKernel);
    \end{minted}
    \caption{Task"=Definition und -Ausführung in Alpaka}
    \label{alpaka:ueberblick:axpy:kernel:task}
\end{code}

\subsubsection{Synchronisierung}
\label{alpaka:ueberblick:axpy:sync}

Nach dem Abschluss der Berechnung ist die Prüfung der Ergebnisse erforderlich.
Dazu werden diese durch eine Kopieroperation zunächst wieder auf den
\textit{Host} übertragen. Dies geschieht wieder in einer \textit{Queue}. Um
auf den Abschluss aller ausstehenden Operationen zu warten, kann der
\textit{Host} durch eine Wartefunktion blockiert werden. Dieser Vorgang wird in
Quelltext~\ref{alpaka:ueberblick:axpy:sync:src} demonstriert.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
alpaka::mem::view::copy(queue, hostBufX, devBufX, extent);
alpaka::mem::view::copy(queue, hostBufY, devBufY, extent);

alpaka::wait::wait(queue); // warte auf ausstehende Operationen

/* ab hier Überprüfung der Ergebnisse möglich */
    \end{minted}
    \caption{Synchronisation zwischen Host und Device in Alpaka}
    \label{alpaka:ueberblick:axpy:sync:src}
\end{code}

\subsubsection{Zusammenfassung}
\label{alpaka:ueberblick:axpy:zusammenfassung}

Der Quelltext~\ref{alpaka:ueberblick:axpy:zusammenfassung:src} zeigt das gesamte
Alpaka"=AXPY"=Beispiel, jedoch aus Platzgründen ohne die Kernel"=Definition.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
#include <cstdlib>
#include <alpaka/alpaka.hpp>

struct AxpyKernel
{
    template <typename TAcc, typename TIdx>
    ALPAKA_FN_ACC auto operator()(const TAcc& acc, const TIdx& numElements,
                            const int a, const int* X, int* Y) const -> void
    {
        /* ... */
    }
};

auto main() -> int
{
    using Dim = alpaka::dim::DimInt<1u>;
    using Idx = std::size_t;
    using Acc = alpaka::acc::AccGpuCudaRt<Dim, Idx>;
    using DevAcc = alpaka::dev::Dev<Acc>;
    using PltfAcc = alpaka::pltf::Pltf<Acc>;
    using PltfHost = alpaka::pltf::PltfCpu;
    using Queue = alpaka::queue::QueueCudaRtNonBlocking;

    auto devHost = alpaka::pltf::getDevByIdx<PltfHost>(0u);
    auto devAcc = alpaka::pltf::getDevByIdx<PltfAcc>(0u);
    auto queue = Queue{devAcc};
    auto extent = alpaka::vec::Vec<Dim, Idx>{numElements};
    auto hostBufX = alpaka::mem::buf::alloc<int, Idx>(devHost, extent);
    auto hostBufY = alpaka::mem::buf::alloc<int, Idx>(devHost, extent);
    auto devBufX = alpaka::mem::buf::alloc<int, Idx>(devAcc, extent);
    auto devBufY = alpaka::mem::buf::alloc<int, Idx>(devAcc, extent);
    auto hostPtrX = alpaka::mem::view::getPtrNative(hostBufX);
    auto hostPtrY = alpaka::mem::view::getPtrNative(hostBufY);

    for(auto i = 0; i < numElements; ++i) {
        hostPtrX[i] = /* ... */;
        hostPtrY[i] = /* ... */;
    }
    alpaka::mem::view::copy(queue, devBufX, hostBufX, extent);
    alpaka::mem::view::copy(queue, devBufY, hostBufY, extent);

    auto workDiv = alpaka::workdiv::getValidWorkDiv<Acc>(
                    devAcc, extent, static_cast<Idx>(1u));
    auto taskKernel = alpaka::kernel::createTaskKernel<Acc>(
                        workDiv, AxpyKernel{}, numElements, a,
                        alpaka::mem::view::getPtrNative(devBufX),
                        alpaka::mem::view::getPtrNative(devBufY));
    alpaka::queue::enqueue(queue, taskKernel);
    alpaka::mem::view::copy(queue, hostBufX, devBufX, extent);
    alpaka::mem::view::copy(queue, hostBufY, devBufY, extent);
    alpaka::wait::wait(queue);

    return EXIT_SUCCESS;
}
    \end{minted}
    \caption{Vollständiges Alpaka-AXPY-Beispiel}
    \label{alpaka:ueberblick:axpy:zusammenfassung:src}
\end{code}

\section{Weiterführende Konzepte}\label{alpaka:konzepte}

Zum besseren Verständnis des obigen Beispiels sowie der in den nächsten Kapiteln
geschilderten Schwierigkeiten beim Entwicklungsprozess des Backends ist die
Kenntnis weiterführender Alpaka"=Konzepte notwendig. Dazu gehören insbesondere
die in Alpaka verwendete Hardware"=Abstraktion und die Verwaltung der
Abhängigkeiten zwischen Kerneln. Für den Entwicklungsprozess mit Alpaka sind
außerdem die Methoden für die Fehlerbehandlung und das Profiling relevant.

\subsection{Hardware"=Abstraktion}
\label{alpaka:konzepte:abstraktion}

Alpakas Hardware"=Abstraktion trägt den Namen \textit{Redundant Hierarchical
Parallelism}\cite[vgl.][22]{worpitz2015}. Sie basiert auf dem Prinzip der
Datenparallelität, das heißt der Idee, dass dieselbe Operation parallel auf
verschiedene, gleichartige Daten angewendet werden kann. Ein triviales Beispiel
für einen datenparallelen Algorithmus ist die in diesem Kapitel als Einführung
verwendete AXPY"=Methode: sie führt dieselbe Operation für alle Elemente der
Vektoren $\vec{x}$ und $\vec{y}$ durch. Die im Folgenden erläuterten Konzepte
wurden stark durch die in CUDA und OpenCL vorhandenen Abstraktionen beeinflusst
\cite[vgl.][17]{worpitz2015}.

\subsubsection{Grid und Threads}

Alpaka"=\textit{Threads} sind einer der Grundbausteine des Abstraktionskonzepts.
Ein idealer datenparalleler Algorithmus lässt sich theoretisch optimal durch
einen \textit{Thread} pro Datenelement parallelisieren. Der Begriff
\glqq Thread\grqq\ ist in diesem Zusammenhang nicht mit einem Thread des
Betriebssystems oder einem CUDA"=Thread zu verwechseln -- er repräsentiert
lediglich eine Befehlssequenz, die den gewünschten Algorithmus auf ein einzelnes
Datenelement anwendet \cite[vgl.][17]{worpitz2015}. Konzeptionell entspricht
ein \textit{Thread} also einem \textit{work"=item} aus SYCL und OpenCL. Die
Menge aller \textit{Threads} bildet ein $n$"=dimensionales Gitter
(engl. \textit{Grid}). Dieses ist damit mit der aus SYCL und OpenCL bekannten
\textit{NDRange} vergleichbar.

Da manche Algorithmen die Kommunikation zwischen \textit{Threads} erfordern,
verfügen diese außerdem über entsprechende Mittel zur Synchronisation. Die
genannte Befehlssequenz pro Element ist der \textit{Kernel}. Die
Abbildung~\ref{alpaka:konzepte:abstraktion:threads:gridthreadhw} zeigt eine
theoretische Hardware, auf die das \textit{Thread}"=\textit{Grid}"=Konzept ideal
anwendbar wäre.

\begin{figure}
    \centering
    \begin{tikzpicture}
        \node [align = center] (abstrtext) at (1.75, 6.75) {\textbf{Abstraktion}};
        \node [align = center] (hwtext) at (9.0834, 6.75) {\textbf{Theoretische Hardware}};

        \draw [rounded corners, fill = HKS41!70] (0.0, 0.0) rectangle (3.5, 5.5);
        \draw [rounded corners, fill = HKS07!70] (0.24, 0.24) rectangle (3.26, 2.5);

        \node [align = center] (gridtext) at (1.75, 5) {\Large\color{white}\textbf{Grid}};
        \node [align = center] (threadtext) at (1.75, 2) {\Large\color{white}\textbf{Thread}};

        \draw [line width = 0.75mm] (4, -0.75) -- (4, 6.25);

        \path [draw, fill = HKS41!70] (4.75, 6) -- (12.4167, 6) -- (13.4167, 5)
                                -- (13.4167, -0.5) -- (5.75, -0.5)
                                -- (4.75, 0.5) -- (4.75, 6);

        \node [text width = 5cm, align = center] (desctext) at (9.0834, 2.3)
              {\color{white}\begin{enumerate}
                  \item 1"=zu"=1"=Abbildung von \textit{Threads} auf Kerne
                  \item n"=zu"=n"=Verbindungen gleicher Länge
              \end{enumerate}};
        \node [align = center] (proctext) at (9.0834, 5) {\Large\color{white}\textbf{Prozessor}};

        \path [draw, fill = HKS07!70] (7.3334, 4.5) -- (8.3334, 4.5) -- (8.4334, 4.4)
                                -- (8.4334, 3.9) -- (7.4334, 3.9) -- (7.3334, 4)
                                -- (7.3334, 4.5);
        \node [align = center] (coretext0) at (7.8834, 4.2) {\color{white}Kern};
        \path [draw, fill = HKS07!70] (8.5334, 4.5) -- (9.5334, 4.5) -- (9.6334, 4.4)
                                -- (9.6334, 3.9) -- (8.6334, 3.9) -- (8.5334, 4)
                                -- (8.5334, 4.5);
        \node [align = center] (coretext1) at (9.0834, 4.2) {\color{white}Kern};
        \path [draw, fill = HKS07!70] (9.7334, 4.5) -- (10.7334, 4.5) -- (10.8334, 4.4)
                                -- (10.8334, 3.9) -- (9.8334, 3.9) -- (9.7334, 4)
                                -- (9.7334, 4.5);
        \node [align = center] (coretext2) at (10.2834, 4.2) {\color{white}Kern};
        \path [draw, fill = HKS07!70] (10.9334, 4.2) -- (11.9334, 4.2) -- (12.0334, 4.1)
                                -- (12.0334, 3.6) -- (11.0334, 3.6) -- (10.9334, 3.7)
                                -- (10.9334, 4.2);
        \node [align = center] (coretext3) at (11.4834, 3.9) {\color{white}Kern};

        \path [draw, fill = HKS07!70] (11.4834, 3.5) -- (12.4834, 3.5) -- (12.5834, 3.4)
                                -- (12.5834, 2.9) -- (11.5834, 2.9) -- (11.4834, 3.0)
                                -- (11.4834, 3.5);
        \node [align = center] (coretext4) at (12.0334, 3.2) {\color{white}Kern};

        \path [draw, fill = HKS07!70] (12.0334, 2.8) -- (13.0334, 2.8) -- (13.0434, 2.79)
                                -- (13.0434, 2.69) -- (12.0434, 2.69)
                                -- (12.0334, 2.7) -- (12.0334, 2.8);
        \path [draw, fill = HKS07!70] (12.0334, 2.6017) -- (13.0334, 2.6017) -- (13.0434, 2.5917)
                                -- (13.0434, 2.4917) -- (12.0434, 2.4917)
                                -- (12.0334, 2.5017) -- (12.0334, 2.6017);
        \path [draw, fill = HKS07!70] (12.0334, 2.4034) -- (13.0334, 2.4034) -- (13.0434, 2.3934)
                                -- (13.0434, 2.2934) -- (12.0434, 2.2934)
                                -- (12.0334, 2.3034) -- (12.0334, 2.4034);
        \path [draw, fill = HKS07!70] (12.0334, 2.2051) -- (13.0334, 2.2051) -- (13.0434, 2.1951)
                                -- (13.0434, 2.0951) -- (12.0434, 2.0951)
                                -- (12.0334, 2.1051) -- (12.0334, 2.2051);
        \path [draw, fill = HKS07!70] (12.0334, 2.0068) -- (13.0334, 2.0068) -- (13.0434, 1.9968)
                                -- (13.0434, 1.8968) -- (12.0434, 1.8968)
                                -- (12.0334, 1.9068) -- (12.0334, 2.0068);
        \path [draw, fill = HKS07!70] (12.0334, 1.8058) -- (13.0334, 1.8058) -- (13.0434, 1.7958)
                                -- (13.0434, 1.6958) -- (12.0434, 1.6958)
                                -- (12.0334, 1.7058) -- (12.0334, 1.8058);
        \path [draw, fill = HKS07!70] (12.0334, 1.61) -- (13.0334, 1.61) -- (13.0434, 1.6)
                                -- (13.0434, 1.5) -- (12.0434, 1.5)
                                -- (12.0334, 1.51) -- (12.0334, 1.61);


        \path [draw, fill = HKS07!70] (11.4834, 1.4) -- (12.4834, 1.4) -- (12.5834, 1.3)
                                -- (12.5834, 0.8) -- (11.5834, 0.8) -- (11.4834, 0.9)
                                -- (11.4834, 1.4);
        \node [align = center] (coretext5) at (12.0334, 1.1) {\color{white}Kern};
        \path [draw, fill = HKS07!70] (10.9334, 0.7) -- (11.9334, 0.7) -- (12.0334, 0.6)
                                -- (12.0334, 0.1) -- (11.0334, 0.1) -- (10.9334, 0.2)
                                -- (10.9334, 0.7);
        \node [align = center] (coretext6) at (11.4834, 0.4) {\color{white}Kern};

        \path [draw, fill = HKS07!70] (9.7334, 0.4) -- (10.7334, 0.4) -- (10.8334, 0.3)
                                -- (10.8334, -0.2) -- (9.8334, -0.2) -- (9.7334, -0.1)
                                -- (9.7334, 0.4);
        \node [align = center] (coretext7) at (10.2834, 0.1) {\color{white}Kern};
        \path [draw, fill = HKS07!70] (8.5334, 0.4) -- (9.5334, 0.4) -- (9.6334, 0.3)
                                -- (9.6334, -0.2) -- (8.6334, -0.2) -- (8.5334, -0.1)
                                -- (8.5334, 0.4);
        \node [align = center] (coretext8) at (9.0834, 0.1) {\color{white}Kern};
        \path [draw, fill = HKS07!70] (7.3334, 0.4) -- (8.3334, 0.4) -- (8.4334, 0.3)
                                -- (8.4334, -0.2) -- (7.4334, -0.2) -- (7.3334, -0.1)
                                -- (7.3334, 0.4);
        \node [align = center] (coretext9) at (7.8834, 0.1) {\color{white}Kern};
        \path [draw, fill = HKS07!70] (6.1334, 0.7) -- (7.1334, 0.7) -- (7.2334, 0.6)
                                -- (7.2334, 0.1) -- (6.2334, 0.1) -- (6.1334, 0.2)
                                -- (6.1334, 0.7);
        \node [align = center] (coretext10) at (6.6834, 0.4) {\color{white}Kern};
        \path [draw, fill = HKS07!70] (5.5334, 1.4) -- (6.5334, 1.4) -- (6.6334, 1.3)
                                -- (6.6334, 0.8) -- (5.6334, 0.8) -- (5.5334, 0.9)
                                -- (5.5334, 1.4);
        \node [align = center] (coretext11) at (6.0834, 1.1) {\color{white}Kern};
        \path [draw, fill = HKS07!70] (5.3334, 2.1) -- (6.3334, 2.1) -- (6.4334, 2.0)
                                -- (6.4334, 1.5) -- (5.4334, 1.5) -- (5.3334, 1.6)
                                -- (5.3334, 2.1);
        \node [align = center] (coretext12) at (5.8834, 1.8) {\color{white}Kern};
        \path [draw, fill = HKS07!70] (5.3334, 2.8) -- (6.3334, 2.8) -- (6.4334, 2.7)
                                -- (6.4334, 2.2) -- (5.4334, 2.2) -- (5.3334, 2.3)
                                -- (5.3334, 2.8);
        \node [align = center] (coretext13) at (5.8834, 2.5) {\color{white}Kern};
        \path [draw, fill = HKS07!70] (5.5834, 3.5) -- (6.5834, 3.5) -- (6.6834, 3.4)
                                -- (6.6834, 2.9) -- (5.6834, 2.9) -- (5.5834, 3.0)
                                -- (5.5834, 3.5);
        \node [align = center] (coretext14) at (6.1334, 3.2) {\color{white}Kern};
        \path [draw, fill = HKS07!70] (6.1334, 4.2) -- (7.1334, 4.2) -- (7.2334, 4.1)
                                -- (7.2334, 3.6) -- (6.2334, 3.6) -- (6.1334, 3.7)
                                -- (6.1334, 4.2);
        \node [align = center] (coretext15) at (6.6834, 3.9) {\color{white}Kern};
    \end{tikzpicture}
    \caption{Links: Abstraktionshierarchie mit einem aus \textit{Threads}
             zusammengesetzten \textit{Grid}. Rechts: Ein hypothetischer
             Prozessor, der datenparallele Anwendungen mit diesem
             Abstraktionsschema ideal ausführen könnte.
             \cite[nach][18]{worpitz2015}}
    \label{alpaka:konzepte:abstraktion:threads:gridthreadhw}
\end{figure}

\subsubsection{Blocks}

Eine wie in Abbildung~\ref{alpaka:konzepte:abstraktion:threads:gridthreadhw}
dargestellte Hardware mit tausenden untereinander verbundenen Kernen kommt
in der Realität selten vor. Es ist daher sinnvoll, eine Einschränkung der
Kommunikations"= und Synchronisationsfähigkeiten der \textit{Threads} auf ein
von handelsüblicher Hardware beherrschbares Niveau vorzunehmen.

Zu diesem Zweck verwendet Alpaka eine weitere Ebene innerhalb der
Abstraktionshierarchie, die \textit{Blocks}. Diese sind zwischen der
\textit{Thread}"= und \textit{Grid}"=Ebene angesiedelt, wobei ein \textit{Block}
eine Teilmenge der \textit{Threads} vereinigt. Das \textit{Grid} wird dabei
gleichmäßig auf die \textit{Blocks} aufgeteilt, sodass alle \textit{Block}
gleich groß sind. Konzeptionell entspricht ein \textit{Block} damit einer
SYCL"=\textit{work"=group}. Die schnelle Kommunikation und Synchronisation der
\textit{Threads} sind ausschließlich über einen \textit{block}"=internen kleinen
gemeinsamen Speicher (\textit{shared memory}) möglich, jedoch nicht mehr über
das gesamte \textit{Grid}. Eine für dieses Abstraktionsschema ideale
theoretische Hardware ist in
Abbildung~\ref{alpaka:konzepte:abstraktion:blocks:gridblockhw} dargestellt.
Diese erlaubt die \textit{block}"=interne Kommunikation, muss jedoch keine
Fähigkeiten für die Kommunikation bzw. Synchronisation zwischen \textit{Blocks}
besitzen.

\begin{figure}
    \centering
    \begin{tikzpicture}
        \node [align = center] (abstrtext) at (1.75, 6.75) {\textbf{Abstraktion}};
        \node [align = center] (hwtext) at (9.0834, 6.75) {\textbf{Theoretische Hardware}};

        \draw [rounded corners, fill = HKS41!70] (0.0, 0.0) rectangle (3.5, 5.5);
        \draw [rounded corners, fill = HKS57!70] (0.08, 0.08) rectangle (3.42, 4.5);
        \draw [rounded corners, fill = HKS07!70] (0.24, 0.24) rectangle (3.26, 2.5);

        \node [align = center] (gridtext) at (1.75, 5) {\Large\color{white}\textbf{Grid}};
        \node [align = center] (blocktext) at (1.75, 4) {\Large\color{white}\textbf{Block}};
        \node [align = center] (threadtext) at (1.75, 2) {\Large\color{white}\textbf{Thread}};

        \draw [line width = 0.75mm] (4, -0.75) -- (4, 6.25);

        \path [draw, fill = HKS41!70] (4.75, 6) -- (12.4167, 6) -- (13.4167, 5)
                                -- (13.4167, -0.5) -- (5.75, -0.5)
                                -- (4.75, 0.5) -- (4.75, 6);

        \node [align = center] (proctext) at (9.0834, 5) {\Large\color{white}\textbf{Prozessor}};
        \node [align = center] (desctext) at (9.5834, -0.25) {\small\color{white}1"=zu"=1"=Abbildung von \textit{Threads} auf Kerne};

        % obere Reihe
        \path [draw, fill = HKS57!70] (5.45, 2.35) -- (5.2, 2.6) -- (5.2, 4.6)
                                -- (7.95, 4.6) -- (8.2, 4.35)
                                -- (8.2, 2.35) -- (5.45, 2.35);
        \path [draw, fill = HKS07!70] (5.55, 2.45) -- (5.45, 2.55) -- (5.45, 3.05)
                                -- (6.45, 3.05) -- (6.55, 2.95) -- (6.55, 2.45)
                                -- (5.55, 2.45);
        \path [draw, fill = HKS07!70] (5.55, 3.9) -- (5.45, 4.0) -- (5.45, 4.5)
                                -- (6.45, 4.5) -- (6.55, 4.4) -- (6.55, 3.9)
                                -- (5.55, 3.9);
        \path [draw, fill = HKS07!70] (6.95, 3.9) -- (6.85, 4.0) -- (6.85, 4.5)
                                -- (7.85, 4.5) -- (7.95, 4.4) -- (7.95, 3.9)
                                -- (6.95, 3.9);
        \path [draw, fill = HKS07!70] (6.95, 2.45) -- (6.85, 2.55) -- (6.85, 3.05)
                                -- (7.85, 3.05) -- (7.95, 2.95) -- (7.95, 2.45)
                                -- (6.95, 2.45);
        \node [align = center] (coretext0) at (6, 2.75) {\color{white}Kern};
        \node [align = center] (coretext1) at (6, 4.2) {\color{white}Kern};
        \node [align = center] (coretext2) at (7.4, 4.2) {\color{white}Kern};
        \node [align = center] (coretext3) at (7.4, 2.75) {\color{white}Kern};
        \path [draw, fill = HKS07!100] (5.55, 3.25) -- (5.45, 3.35) -- (5.45, 3.7)
                                -- (7.85, 3.7) -- (7.95, 3.6) -- (7.95, 3.25)
                                -- (5.55, 3.25);
        \node [align = center] (sharedtext0) at (6.7, 3.475) {\footnotesize\color{white}geteilter Speicher};
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (6, 2.95) -- (6, 3.35);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (6, 4.0) -- (6, 3.6);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (7.4, 2.95) -- (7.4, 3.35);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (7.4, 4.0) -- (7.4, 3.6);

        \path [draw, fill = HKS57!70] (8.55, 2.35) -- (8.3, 2.6) -- (8.3, 4.6)
                                -- (11.05, 4.6) -- (11.3, 4.35)
                                -- (11.3, 2.35) -- (8.55, 2.35);
        \path [draw, fill = HKS07!70] (8.65, 2.45) -- (8.55, 2.55) -- (8.55, 3.05)
                                -- (9.55, 3.05) -- (9.65, 2.95) -- (9.65, 2.45)
                                -- (8.65, 2.45);
        \path [draw, fill = HKS07!70] (8.65, 3.9) -- (8.55, 4.0) -- (8.55, 4.5)
                                -- (9.55, 4.5) -- (9.65, 4.4) -- (9.65, 3.9)
                                -- (8.65, 3.9);
        \path [draw, fill = HKS07!70] (10.05, 3.9) -- (9.95, 4.0) -- (9.95, 4.5)
                                -- (10.95, 4.5) -- (11.05, 4.4) -- (11.05, 3.9)
                                -- (10.05, 3.9);
        \path [draw, fill = HKS07!70] (10.05, 2.45) -- (9.95, 2.55) -- (9.95, 3.05)
                                -- (10.95, 3.05) -- (11.05, 2.95) -- (11.05, 2.45)
                                -- (10.05, 2.45);
        \node [align = center] (coretext4) at (9.1, 2.75) {\color{white}Kern};
        \node [align = center] (coretext5) at (9.1, 4.2) {\color{white}Kern};
        \node [align = center] (coretext6) at (10.5, 4.2) {\color{white}Kern};
        \node [align = center] (coretext7) at (10.5, 2.75) {\color{white}Kern};
        \path [draw, fill = HKS07!100] (8.65, 3.25) -- (8.55, 3.35) -- (8.55, 3.7)
                                -- (10.95, 3.7) -- (11.05, 3.6) -- (11.05, 3.25)
                                -- (8.65, 3.25);
        \node [align = center] (sharedtext1) at (9.8, 3.475) {\footnotesize\color{white}geteilter Speicher};
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (9.1, 2.95) -- (9.1, 3.35);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (9.1, 4.0) -- (9.1, 3.6);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (10.5, 2.95) -- (10.5, 3.35);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (10.5, 4.0) -- (10.5, 3.6);

        \path [draw, fill = HKS57!70] (11.4, 4.6) -- (11.6, 4.6) -- (11.7, 4.5)
                                -- (11.7, 2.35) -- (11.5, 2.35) -- (11.4, 2.45)
                                -- (11.4, 4.6);
        \path [draw, fill = HKS57!70] (11.8, 4.6) -- (12, 4.6) -- (12.1, 4.5)
                                -- (12.1, 2.35) -- (11.9, 2.35) -- (11.8, 2.45)
                                -- (11.8, 4.6);
        \path [draw, fill = HKS57!70] (12.2, 4.6) -- (12.4, 4.6) -- (12.5, 4.5)
                                -- (12.5, 2.35) -- (12.3, 2.35) -- (12.2, 2.45)
                                -- (12.2, 4.6);
        \path [draw, fill = HKS57!70] (12.6, 4.6) -- (12.8, 4.6) -- (12.9, 4.5)
                                -- (12.9, 2.35) -- (12.7, 2.35) -- (12.6, 2.45)
                                -- (12.6, 4.6);
        % untere Reihe
        \path [draw, fill = HKS57!70] (5.45, 0) -- (5.2, 0.25) -- (5.2, 2.25)
                                -- (7.95, 2.25) -- (8.2, 2)
                                -- (8.2, 0) -- (5.45, 0);
        \path [draw, fill = HKS07!70] (5.55, 0.1) -- (5.45, 0.2) -- (5.45, 0.7)
                                -- (6.45, 0.7) -- (6.55, 0.6) -- (6.55, 0.1)
                                -- (5.55, 0.1);
        \path [draw, fill = HKS07!70] (5.55, 1.55) -- (5.45, 1.65) -- (5.45, 2.15)
                                -- (6.45, 2.15) -- (6.55, 2.05) -- (6.55, 1.55)
                                -- (5.55, 1.55);
        \path [draw, fill = HKS07!70] (6.95, 1.55) -- (6.85, 1.65) -- (6.85, 2.15)
                                -- (7.85, 2.15) -- (7.95, 2.05) -- (7.95, 1.55)
                                -- (6.95, 1.55);
        \path [draw, fill = HKS07!70] (6.95, 0.1) -- (6.85, 0.2) -- (6.85, 0.7)
                                -- (7.85, 0.7) -- (7.95, 0.6) -- (7.95, 0.1)
                                -- (6.95, 0.1);
        \node [align = center] (coretext8) at (6, 0.4) {\color{white}Kern};
        \node [align = center] (coretext9) at (6, 1.85) {\color{white}Kern};
        \node [align = center] (coretext10) at (7.4, 1.85) {\color{white}Kern};
        \node [align = center] (coretext11) at (7.4, 0.4) {\color{white}Kern};
        \path [draw, fill = HKS07!100] (5.55, 0.9) -- (5.45, 1.0) -- (5.45, 1.35)
                                -- (7.85, 1.35) -- (7.95, 1.25) -- (7.95, 0.9)
                                -- (5.55, 0.9);
        \node [align = center] (sharedtext2) at (6.7, 1.125) {\footnotesize\color{white}geteilter Speicher};
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (6, 0.6) -- (6, 1.0);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (6, 1.65) -- (6, 1.25);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (7.4, 0.6) -- (7.4, 1.0);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (7.4, 1.65) -- (7.4, 1.25);

        \path [draw, fill = HKS57!70] (8.55, 0) -- (8.3, 0.25) -- (8.3, 2.25)
                                -- (11.05, 2.25) -- (11.3, 2)
                                -- (11.3, 0) -- (8.55, 0);
        \path [draw, fill = HKS07!70] (8.65, 0.1) -- (8.55, 0.2) -- (8.55, 0.7)
                                -- (9.55, 0.7) -- (9.65, 0.6) -- (9.65, 0.1)
                                -- (8.65, 0.1);
        \path [draw, fill = HKS07!70] (8.65, 1.55) -- (8.55, 1.65) -- (8.55, 2.15)
                                -- (9.55, 2.15) -- (9.65, 2.05) -- (9.65, 1.55)
                                -- (8.65, 1.55);
        \path [draw, fill = HKS07!70] (10.05, 1.55) -- (9.95, 1.65) -- (9.95, 2.15)
                                -- (10.95, 2.15) -- (11.05, 2.05) -- (11.05, 1.55)
                                -- (10.05, 1.55);
        \path [draw, fill = HKS07!70] (10.05, 0.1) -- (9.95, 0.2) -- (9.95, 0.7)
                                -- (10.95, 0.7) -- (11.05, 0.6) -- (11.05, 0.1)
                                -- (10.05, 0.1);
        \node [align = center] (coretext12) at (9.1, 0.4) {\color{white}Kern};
        \node [align = center] (coretext13) at (9.1, 1.85) {\color{white}Kern};
        \node [align = center] (coretext14) at (10.5, 1.85) {\color{white}Kern};
        \node [align = center] (coretext15) at (10.5, 0.4) {\color{white}Kern};
        \path [draw, fill = HKS07!100] (8.65, 0.9) -- (8.55, 1.0) -- (8.55, 1.35)
                                -- (10.95, 1.35) -- (11.05, 1.25) -- (11.05, 0.9)
                                -- (8.65, 0.9);
        \node [align = center] (sharedtext3) at (9.8, 1.125) {\footnotesize\color{white}geteilter Speicher};
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (9.1, 0.6) -- (9.1, 1.0);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (9.1, 1.65) -- (9.1, 1.25);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (10.5, 0.6) -- (10.5, 1.0);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (10.5, 1.65) -- (10.5, 1.25);

        \path [draw, fill = HKS57!70] (11.4, 2.25) -- (11.6, 2.25) -- (11.7, 2.15)
                                -- (11.7, 0) -- (11.5, 0) -- (11.4, 0.1)
                                -- (11.4, 2.25);
        \path [draw, fill = HKS57!70] (11.8, 2.25) -- (12, 2.25) -- (12.1, 2.15)
                                -- (12.1, 0) -- (11.9, 0) -- (11.8, 0.1)
                                -- (11.8, 2.25);
        \path [draw, fill = HKS57!70] (12.2, 2.25) -- (12.4, 2.25) -- (12.5, 2.15)
                                -- (12.5, 0) -- (12.3, 0) -- (12.2, 0.1)
                                -- (12.2, 2.25);
        \path [draw, fill = HKS57!70] (12.6, 2.25) -- (12.8, 2.25) -- (12.9, 2.15)
                                -- (12.9, 0) -- (12.7, 0) -- (12.6, 0.1)
                                -- (12.6, 2.25);

    \end{tikzpicture}
    \caption{Links: Abstraktionshierarchie mit einem \textit{Grid}, das aus
             zu \textit{Blocks} gruppierten \textit{Threads} besteht.
             Rechts: Ein theoretischer Prozessor, der eine 1"=zu"=1"=Abbildung
             von \textit{Threads} auf Kerne sowie schnelle Synchronisation und
             Kommunikation innerhalb der \textit{Blocks} ermöglicht.
             \cite[nach][19]{worpitz2015}}
    \label{alpaka:konzepte:abstraktion:blocks:gridblockhw}
\end{figure}

\subsubsection{Warps}

Auf einigen Hardware"=Plattformen können \textit{Thread}"=Gruppen innerhalb
eines \textit{Blocks} taktgenau gemeinsam ausgeführt werden. Diese Gruppen
werden in der Alpaka"=Hierarchie mit dem CUDA"=Begriff \textit{Warp} bezeichnet.
Das \textit{Warp}"=Konzept findet sich beispielsweise auf GPUs, deren
Multiprozessoren \textit{Threads} in \textit{Warp}"=Form ausführen. Dadurch
können sich \textit{Threads} Hardware"=Ressourcen teilen, was die benötigte
Chipfläche verkleinert. Die
Abbildung~\ref{alpaka:konzepte:abstraktion:warps:warphw} zeigt einen
theoretischen Prozessor, der in der Lage ist, das Abstraktionskonzept aus
\textit{Grid}, \textit{Blocks}, \textit{Warps} und \textit{Threads} auszuführen.

Die konkrete \textit{Warp}"=Größe unterscheidet sich zwischen verschiedenen
Plattformen und Herstellern. Aufgrund ihrer Hardware"=Nähe steht diese
Information in OpenCL und SYCL zur Laufzeit zur Verfügung, ist dort jedoch kein
eigener Teil des Abstraktionskonzepts. Alpaka stellt diese Information dagegen
nicht zur Verfügung, obwohl \textit{Warps} im theoretischen Konzept vorhanden
sind.

\begin{figure}
    \centering
    \begin{tikzpicture}
        \node [align = center] (abstrtext) at (1.75, 6.75) {\textbf{Abstraktion}};
        \node [align = center] (hwtext) at (9.0834, 6.75) {\textbf{Theoretische Hardware}};

        \draw [rounded corners, fill = HKS41!70] (0.0, 0.0) rectangle (3.5, 5.5);
        \draw [rounded corners, fill = HKS57!70] (0.08, 0.08) rectangle (3.42, 4.5);
        \draw [rounded corners, fill = HKS33!70] (0.16, 0.16) rectangle (3.34, 3.5);
        \draw [rounded corners, fill = HKS07!70] (0.24, 0.24) rectangle (3.26, 2.5);

        \node [align = center] (gridtext) at (1.75, 5) {\Large\color{white}\textbf{Grid}};
        \node [align = center] (blocktext) at (1.75, 4) {\Large\color{white}\textbf{Block}};
        \node [align = center] (warptext) at (1.75, 3) {\Large\color{white}\textbf{Warp}};
        \node [align = center] (threadtext) at (1.75, 2) {\Large\color{white}\textbf{Thread}};

        \draw [line width = 0.75mm] (4, -0.75) -- (4, 6.25);

        \path [draw, fill = HKS41!70] (4.75, 6) -- (12.4167, 6) -- (13.4167, 5)
                                      -- (13.4167, -0.5) -- (5.75, -0.5)
                                      -- (4.75, 0.5) -- (4.75, 6);

        \node [align = center] (proctext) at (9.0834, 5) {\Large\color{white}\textbf{Prozessor}};

        % obere Reihe
        \path [draw, fill = HKS57!70] (5.45, 2.35) -- (5.2, 2.6) -- (5.2, 4.6)
                                      -- (8.75, 4.6) -- (9, 4.35)
                                      -- (9, 2.35) -- (5.45, 2.35);
        \path [draw, fill = HKS07!100] (5.55, 2.45) -- (5.45, 2.55)
                                       -- (5.45, 2.9) -- (8.65, 2.9)
                                       -- (8.75, 2.8) -- (8.75, 2.45)
                                       -- (5.55, 2.45);
        \node [align = center] (sharedtext0) at (7.1, 2.675) {\small\color{white}geteilter Speicher};
        \path [draw, fill = HKS07!70] (7.15, 3.9) -- (7.05, 4.0) -- (7.05, 4.5)
                                -- (8.05, 4.5) -- (8.15, 4.4) -- (8.15, 3.9)
                                -- (7.15, 3.9);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (7.6, 4.05) -- (7.6, 2.75);
        \path [draw, fill = HKS07!70] (7.35, 3.9) -- (7.25, 4.0) -- (7.25, 4.5)
                                -- (8.25, 4.5) -- (8.35, 4.4) -- (8.35, 3.9)
                                -- (7.35, 3.9);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (7.8, 4.05) -- (7.8, 2.75);
        \path [draw, fill = HKS07!70] (7.55, 3.9) -- (7.45, 4.0) -- (7.45, 4.5)
                                -- (8.45, 4.5) -- (8.55, 4.4) -- (8.55, 3.9)
                                -- (7.55, 3.9);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (8.0, 4.05) -- (8.0, 2.75);
        \path [draw, fill = HKS07!70] (7.75, 3.9) -- (7.65, 4.0) -- (7.65, 4.5)
                                -- (8.65, 4.5) -- (8.75, 4.4) -- (8.75, 3.9)
                                -- (7.75, 3.9);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (8.2, 4.05) -- (8.2, 2.75);
        \node [align = center] (coretext0) at (8.2, 4.2) {\color{white}Kern};
        \path [draw, fill = HKS33!70] (5.55, 4.0) -- (5.45, 4.1) -- (5.45, 4.5)
                                      -- (6.7, 4.5) -- (6.8, 4.4)
                                      -- (6.8, 4.0) -- (5.55, 4.0);
        \path [draw, fill = HKS33!70] (5.55, 3.8) -- (5.45, 3.9) -- (5.45, 4.3)
                                      -- (6.7, 4.3) -- (6.8, 4.2)
                                      -- (6.8, 3.8) -- (5.55, 3.8);
        \path [draw, fill = HKS33!70] (5.55, 3.6) -- (5.45, 3.7) -- (5.45, 4.1)
                                      -- (6.7, 4.1) -- (6.8, 4.0)
                                      -- (6.8, 3.6) -- (5.55, 3.6);
        \path [draw, fill = HKS33!70] (5.55, 3.4) -- (5.45, 3.5) -- (5.45, 3.9)
                                      -- (6.7, 3.9) -- (6.8, 3.8)
                                      -- (6.8, 3.4) -- (5.55, 3.4);
        \path [draw, fill = HKS33!70] (5.55, 3.2) -- (5.45, 3.3) -- (5.45, 3.7)
                                      -- (6.7, 3.7) -- (6.8, 3.6)
                                      -- (6.8, 3.2) -- (5.55, 3.2);
        \path [draw, fill = HKS33!70] (5.55, 3.0) -- (5.45, 3.1) -- (5.45, 3.5)
                                      -- (6.7, 3.5) -- (6.8, 3.4)
                                      -- (6.8, 3.0) -- (5.55, 3.0);
        \node [align = center] (warptext0) at (6.125, 3.25) {\small\color{white}Warp};

        \path [draw, fill = HKS57!70] (9.4, 2.35) -- (9.15, 2.6) -- (9.15, 4.6)
                                      -- (12.7167, 4.6) -- (12.9667, 4.35)
                                      -- (12.9667, 2.35) -- (9.4, 2.35);
        \path [draw, fill = HKS07!100] (9.5, 2.45) -- (9.4, 2.55)
                                       -- (9.4, 2.9) -- (12.6, 2.9)
                                       -- (12.7, 2.8) -- (12.7, 2.45)
                                       -- (9.5, 2.45);
        \node [align = center] (sharedtext1) at (11.05, 2.675) {\small\color{white}geteilter Speicher};
        \path [draw, fill = HKS07!70] (11.1, 3.9) -- (11.0, 4.0) -- (11.0, 4.5)
                                -- (12.0, 4.5) -- (12.1, 4.4) -- (12.1, 3.9)
                                -- (11.1, 3.9);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (11.55, 4.05) -- (11.55, 2.75);
        \path [draw, fill = HKS07!70] (11.3, 3.9) -- (11.2, 4.0) -- (11.2, 4.5)
                                -- (12.2, 4.5) -- (12.3, 4.4) -- (12.3, 3.9)
                                -- (11.3, 3.9);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (11.75, 4.05) -- (11.75, 2.75);
        \path [draw, fill = HKS07!70] (11.5, 3.9) -- (11.4, 4.0) -- (11.4, 4.5)
                                -- (12.4, 4.5) -- (12.5, 4.4) -- (12.5, 3.9)
                                -- (11.5, 3.9);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (11.95, 4.05) -- (11.95, 2.75);
        \path [draw, fill = HKS07!70] (11.7, 3.9) -- (11.6, 4.0) -- (11.6, 4.5)
                                -- (12.6, 4.5) -- (12.7, 4.4) -- (12.7, 3.9)
                                -- (11.7, 3.9);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (12.15, 4.05) -- (12.15, 2.75);
        \node [align = center] (coretext1) at (12.15, 4.2) {\color{white}Kern};
        \path [draw, fill = HKS33!70] (9.5, 4.0) -- (9.4, 4.1) -- (9.4, 4.5)
                                      -- (10.65, 4.5) -- (10.75, 4.4)
                                      -- (10.75, 4.0) -- (9.5, 4.0);
        \path [draw, fill = HKS33!70] (9.5, 3.8) -- (9.4, 3.9) -- (9.4, 4.3)
                                      -- (10.65, 4.3) -- (10.75, 4.2)
                                      -- (10.75, 3.8) -- (9.5, 3.8);
        \path [draw, fill = HKS33!70] (9.5, 3.6) -- (9.4, 3.7) -- (9.4, 4.1)
                                      -- (10.65, 4.1) -- (10.75, 4.0)
                                      -- (10.75, 3.6) -- (9.5, 3.6);
        \path [draw, fill = HKS33!70] (9.5, 3.4) -- (9.4, 3.5) -- (9.4, 3.9)
                                      -- (10.65, 3.9) -- (10.75, 3.8)
                                      -- (10.75, 3.4) -- (9.5, 3.4);
        \path [draw, fill = HKS33!70] (9.5, 3.2) -- (9.4, 3.3) -- (9.4, 3.7)
                                      -- (10.65, 3.7) -- (10.75, 3.6)
                                      -- (10.75, 3.2) -- (9.5, 3.2);
        \path [draw, fill = HKS33!70] (9.5, 3.0) -- (9.4, 3.1) -- (9.4, 3.5)
                                      -- (10.65, 3.5) -- (10.75, 3.4)
                                      -- (10.75, 3.0) -- (9.5, 3.0);
        \node [align = center] (warptext1) at (10.075, 3.25) {\small\color{white}Warp};

        % untere Reihe
        \path [draw, fill = HKS57!70] (5.45, 0) -- (5.2, 0.25) -- (5.2, 2.25)
                                      -- (8.75, 2.25) -- (9, 2)
                                      -- (9, 0) -- (5.45, 0);
        \path [draw, fill = HKS07!100] (5.55, 0.1) -- (5.45, 0.2)
                                       -- (5.45, 0.55) -- (8.65, 0.55)
                                       -- (8.75, 0.45) -- (8.75, 0.1)
                                       -- (5.55, 0.1);
        \node [align = center] (sharedtext2) at (7.1, 0.325) {\small\color{white}geteilter Speicher};
        \path [draw, fill = HKS07!70] (7.15, 1.55) -- (7.05, 1.65) -- (7.05, 2.15)
                                -- (8.05, 2.15) -- (8.15, 2.05) -- (8.15, 1.55)
                                -- (7.15, 1.55);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (7.6, 1.7) -- (7.6, 0.4);
        \path [draw, fill = HKS07!70] (7.35, 1.55) -- (7.25, 1.65) -- (7.25, 2.15)
                                -- (8.25, 2.15) -- (8.35, 2.05) -- (8.35, 1.55)
                                -- (7.35, 1.55);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (7.8, 1.7) -- (7.8, 0.4);
        \path [draw, fill = HKS07!70] (7.55, 1.55) -- (7.45, 1.65) -- (7.45, 2.15)
                                -- (8.45, 2.15) -- (8.55, 2.05) -- (8.55, 1.55)
                                -- (7.55, 1.55);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (8.0, 1.7) -- (8.0, 0.4);
        \path [draw, fill = HKS07!70] (7.75, 1.55) -- (7.65, 1.65) -- (7.65, 2.15)
                                -- (8.65, 2.15) -- (8.75, 2.05) -- (8.75, 1.55)
                                -- (7.75, 1.55);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (8.2, 1.7) -- (8.2, 0.4);
        \node [align = center] (coretext2) at (8.2, 1.85) {\color{white}Kern};
        \path [draw, fill = HKS33!70] (5.55, 1.65) -- (5.45, 1.75) -- (5.45, 2.15)
                                      -- (6.7, 2.15) -- (6.8, 2.05)
                                      -- (6.8, 1.65) -- (5.55, 1.65);
        \path [draw, fill = HKS33!70] (5.55, 1.45) -- (5.45, 1.55) -- (5.45, 1.95)
                                      -- (6.7, 1.95) -- (6.8, 1.85)
                                      -- (6.8, 1.45) -- (5.55, 1.45);
        \path [draw, fill = HKS33!70] (5.55, 1.25) -- (5.45, 1.35) -- (5.45, 1.75)
                                      -- (6.7, 1.75) -- (6.8, 1.65)
                                      -- (6.8, 1.25) -- (5.55, 1.25);
        \path [draw, fill = HKS33!70] (5.55, 1.05) -- (5.45, 1.15) -- (5.45, 1.55)
                                      -- (6.7, 1.55) -- (6.8, 1.45)
                                      -- (6.8, 1.05) -- (5.55, 1.05);
        \path [draw, fill = HKS33!70] (5.55, 0.85) -- (5.45, 0.95) -- (5.45, 1.35)
                                      -- (6.7, 1.35) -- (6.8, 1.25)
                                      -- (6.8, 0.85) -- (5.55, 0.85);
        \path [draw, fill = HKS33!70] (5.55, 0.65) -- (5.45, 0.75) -- (5.45, 1.15)
                                      -- (6.7, 1.15) -- (6.8, 1.05)
                                      -- (6.8, 0.65) -- (5.55, 0.65);
        \node [align = center] (warptext2) at (6.125, 0.9) {\small\color{white}Warp};

        \path [draw, fill = HKS57!70] (9.4, 0) -- (9.15, 0.25) -- (9.15, 2.25)
                                      -- (12.7167, 2.25) -- (12.9667, 2)
                                      -- (12.9667, 0) -- (9.4, 0);
        \path [draw, fill = HKS07!100] (9.5, 0.1) -- (9.4, 0.2)
                                       -- (9.4, 0.55) -- (12.6, 0.55)
                                       -- (12.7, 0.45) -- (12.7, 0.1)
                                       -- (9.5, 0.1);
        \node [align = center] (sharedtext3) at (11.05, 0.325) {\small\color{white}geteilter Speicher};
        \path [draw, fill = HKS07!70] (11.1, 1.55) -- (11.0, 1.65) -- (11.0, 2.15)
                                -- (12.0, 2.15) -- (12.1, 2.05) -- (12.1, 1.55)
                                -- (11.1, 1.55);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (11.55, 1.7) -- (11.55, 0.4);
        \path [draw, fill = HKS07!70] (11.3, 1.55) -- (11.2, 1.65) -- (11.2, 2.15)
                                -- (12.2, 2.15) -- (12.3, 2.05) -- (12.3, 1.55)
                                -- (11.3, 1.55);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (11.75, 1.7) -- (11.75, 0.4);
        \path [draw, fill = HKS07!70] (11.5, 1.55) -- (11.4, 1.65) -- (11.4, 2.15)
                                -- (12.4, 2.15) -- (12.5, 2.05) -- (12.5, 1.55)
                                -- (11.5, 1.55);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (11.95, 1.7) -- (11.95, 0.4);
        \path [draw, fill = HKS07!70] (11.7, 1.55) -- (11.6, 1.65) -- (11.6, 2.15)
                                -- (12.6, 2.15) -- (12.7, 2.05) -- (12.7, 1.55)
                                -- (11.7, 1.55);
        \draw [{Latex[scale=0.5]}-{Latex[scale = 0.5]}, very thick] (12.15, 1.7) -- (12.15, 0.4);
        \node [align = center] (coretext3) at (12.15, 1.85) {\color{white}Kern};
        \path [draw, fill = HKS33!70] (9.5, 1.65) -- (9.4, 1.75) -- (9.4, 2.15)
                                      -- (10.65, 2.15) -- (10.75, 2.05)
                                      -- (10.75, 1.65) -- (9.5, 1.65);
        \path [draw, fill = HKS33!70] (9.5, 1.45) -- (9.4, 1.55) -- (9.4, 1.95)
                                      -- (10.65, 1.95) -- (10.75, 1.85)
                                      -- (10.75, 1.45) -- (9.5, 1.45);
        \path [draw, fill = HKS33!70] (9.5, 1.25) -- (9.4, 1.35) -- (9.4, 1.75)
                                      -- (10.65, 1.75) -- (10.75, 1.65)
                                      -- (10.75, 1.25) -- (9.5, 1.25);
        \path [draw, fill = HKS33!70] (9.5, 1.05) -- (9.4, 1.15) -- (9.4, 1.55)
                                      -- (10.65, 1.55) -- (10.75, 1.45)
                                      -- (10.75, 1.05) -- (9.5, 1.05);
        \path [draw, fill = HKS33!70] (9.5, 0.85) -- (9.4, 0.95) -- (9.4, 1.35)
                                      -- (10.65, 1.35) -- (10.75, 1.25)
                                      -- (10.75, 0.85) -- (9.5, 0.85);
        \path [draw, fill = HKS33!70] (9.5, 0.65) -- (9.4, 0.75) -- (9.4, 1.15)
                                      -- (10.65, 1.15) -- (10.75, 1.05)
                                      -- (10.75, 0.65) -- (9.5, 0.65);
        \node [align = center] (warptext3) at (10.075, 0.9) {\small\color{white}Warp};

    \end{tikzpicture}
    \caption{Links: Abstraktionshierarchie mit einem \textit{Grid}, das aus
             zu \textit{Blocks} gruppierten \textit{Warps} besteht. Letzere sind
             wiederum aus mehreren \textit{Threads} zusammengesetzt.
             Rechts: Ein theoretischer Prozessor, der eine 1"=zu"=1"=Abbildung
             von \textit{Threads} auf Kerne sowie schnelle Synchronisation und
             Kommunikation innerhalb der \textit{Blocks} ermöglicht. Durch die
             taktgenaue gemeinsame Ausführung der \textit{Threads} in Form von
             \textit{Warps} kann Chipfläche eingespart werden.
             \cite[nach][20]{worpitz2015}}
    \label{alpaka:konzepte:abstraktion:warps:warphw}
\end{figure}

\subsubsection{Elements}

Mit dem \textit{Element}"=Konzept ermöglicht Alpaka dem Programmierer die
genauere Anpassung auf die Ziel"=Hardware. Die Idee, jeden \textit{Thread} genau
ein Datum bearbeiten zu lassen, ist nicht immer der optimale Weg. So kann es
beispielsweise sinnvoll sein, auf CPU"=Beschleunigern mehrere Daten pro
\textit{Thread} innerhalb kurzer Schleifen zu verarbeiten. Dadurch können gute
Compiler selbstständig von Vektorregistern der CPU Gebrauch machen, alternativ
kann der Programmierer dies auch explizit selbst tun.

Die \textit{Element}"=Ebene ist die unterste Ebene der
Alpaka"=Abstraktionshierarchie. Dadurch ergibt sich die Gesamthierarchie, wie
sie in Abbildung~\ref{alpaka:konzepte:abstraktion:elements:vollstaendig}
dargestellt ist.

\begin{figure}
    \centering
    \begin{tikzpicture}
        \draw [rounded corners, fill = HKS41!70] (0.0, 0.0) rectangle (3.5, 5.5);
        \draw [rounded corners, fill = HKS57!70] (0.08, 0.08) rectangle (3.42, 4.5);
        \draw [rounded corners, fill = HKS33!70] (0.16, 0.16) rectangle (3.34, 3.5);
        \draw [rounded corners, fill = HKS07!70] (0.24, 0.24) rectangle (3.26, 2.5);
        \draw [rounded corners, fill = HKS36!70] (0.32, 0.32) rectangle (3.18, 1.5);

        \node [align = center] (gridtext) at (1.75, 5) {\Large\color{white}\textbf{Grid}};
        \node [align = center] (blocktext) at (1.75, 4) {\Large\color{white}\textbf{Block}};
        \node [align = center] (warptext) at (1.75, 3) {\Large\color{white}\textbf{Warp}};
        \node [align = center] (threadtext) at (1.75, 2) {\Large\color{white}\textbf{Thread}};
        \node [align = center] (elemtext) at (1.75, 0.91) {\Large\color{white}\textbf{Element}};
    \end{tikzpicture}
    \caption{Vollständiges Alpaka"=Abstraktionskonzept: Mehrere
             \textit{Elements} werden von einem \textit{Thread} verarbeitet.
             Mehrere \textit{Threads} werden innerhalb eines \textit{Warps}
             taktgenau gemeinsam ausgeführt, mehrere \textit{Warps} bilden
             wiederum einen \textit{Block}. Die Menge aller \textit{Blocks}
             ergibt das \textit{Grid}. \cite[nach][22]{worpitz2015}}
    \label{alpaka:konzepte:abstraktion:elements:vollstaendig}
\end{figure}

\subsection{Abhängigkeiten zwischen Kerneln}
\label{alpaka:konzepte:abhaengigkeiten}

Im Gegensatz zu SYCL verfügt Alpaka nicht über ein System, um automatisch
Abhängigkeiten zwischen Kerneln zu verwalten. Stattdessen ist es Aufgabe des
Programmierers, Alpaka"=\textit{Events}zur Synchronisierung zwischen Kerneln zu
verwenden. Dies ist nötig, da Operationen (Kopien, Kernel, \ldots) in derselben
\textit{Queue} zwar sequentiell in der Reihenfolge ihrer Einreihung
abgearbeitet werden, in verschiedenen \textit{Queues} dagegen zueinander
asynchron laufen.

\begin{code}
    \begin{minted}[fontsize=\small]{c++}
auto queue1 = QueueCudaRtNonBlocking{/*...*/};
auto queue2 = QueueCudaRtNonBlocking{/*...*/};

// A ist Vorbedingung für B und C
auto eventA = EventCudaRt{/* ... */};
// führe A aus und markiere anschließendes Event
alpaka::queue::enqueue(queue1, /* A */);
alpaka::queue::enqueue(queue1, eventA);

// B befindet sich in derselben Queue hinter A
alpaka::queue::enqueue(queue1, /* B */);

// C befindet sich in einer anderen Queue und muss auf eventA warten
alpaka::wait::wait(queue2, eventA);
// C ist Vorbedingung für D
auto eventC = EventCudaRt{/* ... */};
// führe C aus und markiere anschließendes Event
alpaka::queue::enqueue(queue2, /* C */);
alpaka::queue::enqueue(queue2, eventC);

// D befindet sich in derselben Queue hinter B, muss aber auf eventC warten
alpaka::wait::wait(queue1, eventC);
alpaka::queue::enqueue(queue1, /* D */);
    \end{minted}
    \caption{Einfacher Alpaka"=Aufgabengraph}
    \label{alpaka:konzepte:abhaengigkeiten:src}
\end{code}

\textit{Events} können zwischen \textit{Queue}"=Operationen eingefügt werden.
Wurde eine Operation vollständig durchgeführt, so wird das nachfolgende
\textit{Event} entsprechend markiert. Andere \textit{Queues} sowie der
\textit{Host} können dadurch auf dieses \textit{Event} warten, bevor sie ihre
eigenen Aufgaben fortsetzen.

Der im vorigen Abschnitt (Abschnitt~\ref{sycl:konzepte:abhaengigkeiten})
Beispiel"=Aufgabengraph erfordert demnach mehr Aufwand als das SYCL"=Äquivalent,
wie der Quelltext~\ref{alpaka:konzepte:abhaengigkeiten:src} zeigt.

\subsection{Fehlerbehandlung}

Ähnlich wie SYCL verwendet Alpaka C++"=Exceptions für die Fehlerbehandlung zur
Laufzeit. Allerdings wurde darauf verzichtet, spezielle Exceptions für Alpaka
zu entwerfen. Stattdessen wird die Klasse \texttt{runtime\_error} der
C++"=Standardbibliothek verwendet.

\subsection{Profiling}

Im Gegensatz zu SYCL bringt Alpaka keine eigenen Werkzeuge für das Profiling
mit. Da Alpaka zur Compile"=Zeit auf die herstellerspezifischen Schnittstellen
abgebildet wird, ist dies auch nicht nötig -- dem Programmierer stehen so die
vom jeweiligen Hardware"=Hersteller mitgelieferten Profiling"=Werkzeuge zur
Verfügung. So lässt sich beispielsweise der CUDA"=Profiler \texttt{nvprof} für
das Profiling eines mit Alpaka auf NVIDIA"=Hardware portierten Programms
verwenden, was mit den für NVIDIA"=GPUs existierenden SYCL"=Implementierungen
nicht möglich ist.

\subsection{Zusammenfassung}

Die Abbildung~\ref{alpaka:konzepte:zusammenfassung:struktur} zeigt den
konzeptionellen Aufbau der Alpaka"=Bibliothek. Das nächste Kapitel wird zeigen,
wie die einzelnen Bestandteile mit SYCL implementiert wurden.

\begin{figure}
    \centering
    \begin{tikzpicture}
        \draw [rounded corners, fill = HKS33!70] (0, 0) rectangle (2.5, 9.5)
              node [pos = 0.5, align = center, rotate = 90] {\color{white}\textbf{Device}};
        \draw [rounded corners, fill = HKS33!70] (0, 9.75) rectangle (2.5, 19.85)
              node [pos = 0.5, align = center, rotate = 90] {\color{white}\textbf{Host}};
        \draw [rounded corners, fill = HKS33!100] (0, 20.1) rectangle (2.5, 22.1)
              node [pos = 0.5, align = center] {\color{white}\textbf{Domäne}};

        \draw [rounded corners, fill = HKS65!70] (2.75, 0) rectangle (3.95, 8.4)
              node [pos = 0.5, align = center, rotate = 90] {\color{white}\textbf{Alpaka}};
        \draw [rounded corners, fill = HKS65!70] (4.05, 0) rectangle (5.25, 8.4)
              node [pos = 0.5, align = center, rotate = 90] {\color{white}\textbf{Nutzer}};
        \draw [rounded corners, fill = HKS65!70] (2.75, 8.5) rectangle (5.25, 9.5)
              node [pos = 0.5, align = center] {\color{white}\textbf{Nutzer}};
        \draw [rounded corners, fill = HKS65!70] (2.75, 9.75) rectangle (3.95, 19.85)
              node [pos = 0.5, align = center, rotate = 90] {\color{white}\textbf{Alpaka}};
        \draw [rounded corners, fill = HKS65!70] (4.05, 9.75) rectangle (5.25, 19.85)
              node [pos = 0.5, align = center, rotate = 90] {\color{white}\textbf{Nutzer}};
        \draw [rounded corners, fill = HKS65!100] (2.75, 20.1) rectangle (5.25, 22.1)
              node [pos = 0.5, align = center] {\color{white}\textbf{Ursprung}};

        \draw [rounded corners, fill = HKS07!70] (5.5, 0) rectangle (8, 8.4);
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 0.1) rectangle (7.9, 0.85)
              node [pos = 0.5, align = center] {\color{white}\textbf{\ldots}};
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 1.05) rectangle (7.9, 2.05)
              node [pos = 0.5, align = center] {\color{white}\textbf{Math}};
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 2.15) rectangle (7.9, 3.15)
              node [pos = 0.5, align = center] {\color{white}\textbf{Rand}};
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 3.25) rectangle (7.9, 4.25)
              node [pos = 0.5, align = center] {\color{white}\textbf{Atomic}};
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 4.35) rectangle (7.9, 5.35)
              node [pos = 0.5, align = center] {\color{white}\textbf{Index}};
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 5.45) rectangle (7.9, 6.45)
              node [pos = 0.5, align = center] {\color{white}\textbf{Work}\\
                                                \color{white}\textbf{Division}};
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 6.65) rectangle (7.9, 7.15)
              node [pos = 0.5, align = center] {\color{white}\textbf{Size}};
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 7.25) rectangle (7.9, 7.75)
              node [pos = 0.5, align = center] {\color{white}\textbf{Dim}};
        \node [align = center] (acctext) at (6.75, 8.10) {\color{white}\textbf{Accelerator}}; 
        \draw [rounded corners, fill = HKS07!70] (5.5, 8.5) rectangle (8, 9.5)
              node [pos = 0.5, align = center] {\color{white}\textbf{Kernel}};
        \draw [rounded corners, fill = HKS07!70] (5.5, 9.75) rectangle (8, 11.45);
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 9.85) rectangle (7.9, 10.35)
              node [pos = 0.5, align = center] {\color{white}\textbf{Size}};
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 10.45) rectangle (7.9, 10.95)
              node [pos = 0.5, align = center] {\color{white}\textbf{Dim}};
        \node [align = center] (tasktext) at (6.75, 11.2) {\color{white}\textbf{Task}};
        \draw [rounded corners, fill = HKS07!70] (5.5, 11.55) rectangle (8, 15.05);
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 11.65) rectangle (7.9, 14.55);
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.7, 11.75) rectangle (7.8, 12.25)
              node [pos = 0.5, align = center] {\color{white}\textbf{Size}};
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.7, 12.35) rectangle (7.8, 12.85)
              node [pos = 0.5, align = center] {\color{white}\textbf{Dim}};
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.7, 12.95) rectangle (7.8, 13.45)
              node [pos = 0.5, align = center] {\color{white}\textbf{Extent}};
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.7, 13.55) rectangle (7.8, 14.05)
              node [pos = 0.5, align = center] {\color{white}\textbf{Offset}};
        \node [align = center] (viewtext) at (6.75, 14.3) {\color{white}\textbf{View}};
        \node [align = center] (buffertext) at (6.75, 14.8) {\color{white}\textbf{Buffer}};
        \draw [rounded corners, fill = HKS07!70] (5.5, 15.15) rectangle (8, 16.25);
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 15.25) rectangle (7.9, 15.75)
              node [pos = 0.5, align = center] {\color{white}\textbf{Waitable}};
        \node [align = center] (eventtext) at (6.75, 16) {\color{white}\textbf{Event}};
        \draw [rounded corners, fill = HKS07!70] (5.5, 16.35) rectangle (8, 17.45);
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 16.45) rectangle (7.9, 16.95)
              node [pos = 0.5, align = center] {\color{white}\textbf{Waitable}};
        \node [align = center] (eventtext) at (6.75, 17.2) {\color{white}\textbf{Queue}};
        \draw [rounded corners, fill = HKS07!70] (5.5, 17.55) rectangle (8, 18.65);
        \draw [rounded corners, draw = white, fill = HKS07!50] (5.6, 17.65) rectangle (7.9, 18.15)
              node [pos = 0.5, align = center] {\color{white}\textbf{Waitable}};
        \node [align = center] (eventtext) at (6.75, 18.4) {\color{white}\textbf{Device}};
        \draw [rounded corners, fill = HKS07!70] (5.5, 18.75) rectangle (8, 19.85)
              node [pos = 0.5, align = center] {\color{white}\textbf{Device}\\
                                                \color{white}\textbf{Manager}};
        \draw [rounded corners, fill = HKS07!100] (5.5, 20.1) rectangle (8, 22.1)
              node [pos = 0.5, align = center] {\color{white}\textbf{Konzept}};
    \end{tikzpicture}
    \caption{Struktureller Aufbau der Alpaka"=Bibliothek\cite[nach][40]{worpitz2015}}
    \label{alpaka:konzepte:zusammenfassung:struktur}
\end{figure}
