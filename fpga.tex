\chapter{FPGAs als Beschleuniger}

Konzeption und Aufbau der \gls{fpga}s sowie der zugehörige Entwicklungsprozess
werden in diesem Kapitel geschildert. Abschließend werden die auf \gls{fpga}s
und \gls{gpu}s zu findenden Parallelitätskonzepte miteinander verglichen.

\section{Überblick}

Für das Verständnis der Funktionsweise eines \gls{fpga}s ist es notwendig, die
zugrunde liegenden Konzepte in Abgrenzung zu herkömmlicher Hardware
darzustellen. Dieser Abschnitt definiert zunächst den \gls{fpga}-Begriff und
erläutert im Anschluss daran den Aufbau moderner \gls{fpga}-Architekturen sowie
traditionelle und neuartige Nutzungsmöglichkeiten dieses Hardware-Typus.

\subsection{Definition}

\textit{Field-programmable gate arrays} sind, wie der Name andeutet,
konzeptionell mit den \textit{gate arrays} verwandt.

Die klassischen \textit{gate arrays} sind eine Untergruppe der integrierten
Schaltkreise (engl. \textit{integrated circuits}, IC) und gehören zur Gattung
der anwendungsspezifischen ICs (engl. \textit{application specific IC}, ASIC).
Unter ASICs versteht man jene Chips, die bereits bei der Herstellung mit einer
kundenspezifischen Schaltung versehen werden. Innerhalb dieser Kategorie gehören
\textit{gate arrays} zu den teil-vorgefertigten ASICs (engl.
\textit{semi-custom ASIC}). Diese werden zunächst in großer Menge mit demselben
technischen Grundgerüst produziert und erst in einem späteren
Herstellungsschritt in kleineren Mengen mit kundenspezifischen Schaltungen
versehen. Im Gegensatz zu ASICs, die von Anfang an nach Kundenwunsch hergestellt
wurden (engl. \textit{full-custom ASIC}), lässt sich so eine Reduktion der
Produktionskosten erreichen. \cite[vgl.][123]{kesel2013}

Allerdings haben \textit{gate arrays} den Nachteil, dass sie nur vom Hersteller
programmiert werden können. Eine Anpassung der Schaltung im Feld (engl.
\textit{field-programmable}) ist damit nicht möglich. Mit \gls{fpga}s wurde
dieses Problem in den 1980er Jahren gelöst, indem man aus Gattern
(engl. \textit{gates}) bestehende Logikzellen von geringer Komplexität in einer
regelmäßigen Feldstruktur (engl. \textit{array}) anordnete und über
programmierbare Verdrahtungen miteinander verband.
\cite[vgl.][208]{kesel2013} 

Mittlerweile gibt es viele verschiedene \gls{fpga}-Varianten, die jedoch einige
Gemeinsamkeiten aufweisen. \gls{fpga}s bestehen stets aus einem Feld aus
Blockzellen, die so konfiguriert werden, dass sie eine bestimmte Funktion
ausführen. Diese Blockzellen integrieren durch ein dichtes Verbindungsnetz
Logikgatter und Speicher über ein dichtes Verbindungsnetz. Dabei lassen sich
vier zentrale Strukturen unterscheiden:
\begin{itemize}
    \item konfigurierbare Logikblöcke,
    \item programmierbare Verbindungen,
    \item Puffer für die Ein- und Ausgabe (E/A) und
    \item weitere Elemente (Speicher, arithmetische Einheiten, Taktnetzwerke,
          usw.).
\end{itemize}
In Abbildung~\ref{fpga:definition:aufbau} ist eine abstrakte \gls{fpga}-Struktur
dargestellt, die aus Logikblöcken, Verbindungen, E/A-Puffern und speziellen
Speicher- und Multiplizierer-Blöcken aufgebaut ist.
\cite[vgl.][10-13--10-14]{hawkins2010}

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        % (0,0) ist unten links

        % untere E/A-Reihe
        \draw [fill = HKS41!60]
                (0.0, -1.875) rectangle (1.5, -1.125)
                node[pos = 0.5, text = white, align = center] {\small E/A};
        \draw [fill = HKS41!60]
                (2.625, -1.875) rectangle (4.125, -1.125)
                node[pos = 0.5, text = white, align = center] {\small E/A};
        \draw [fill = HKS41!60]
                (5.25, -1.875) rectangle (6.75, -1.125)
                node[pos = 0.5, text = white, align = center] {\small E/A};
        \draw [fill = HKS41!60]
                (7.875, -1.875) rectangle (9.375, -1.125)
                node[pos = 0.5, text = white, align = center] {\small E/A};

        % Reihe 1
        \draw [fill = HKS41!60]
                (-1.875, 0.0) rectangle (-1.125, 1.5)
                node[pos = 0.5, text = white, align = center] {\small E/A};
        \draw [fill = HKS41!80]
                (0.0, 0.0) rectangle (1.5, 1.5)
                node[pos = 0.5, text = white, align = center] {\small Logik};
        \draw [fill = HKS41!40]
                (2.625, 0.0) rectangle (4.125, 1.5)
                node[pos = 0.5, text = white, align = center] {\small Speicher};
        \draw [fill = HKS41!80]
                (5.25, 0.0) rectangle (6.75, 1.5)
                node[pos = 0.5, text = white, align = center] {\small Logik};
        \draw [fill = HKS41]
                (7.875, 0.0) rectangle (9.375, 1.5)
                node[pos = 0.5, text = white, align = center] {\small Multipli- \\ zierer};
        \draw [fill = HKS41!60]
                (10.5, 0.0) rectangle (11.25, 1.5)
                node[pos = 0.5, text = white, align = center] {\small E/A};

        % Reihe 2
        \draw [fill = HKS41!60]
                (-1.875, 2.625) rectangle (-1.125, 4.125)
                node[pos = 0.5, text = white, align = center] {\small E/A};
        \draw [fill = HKS41!80]
                (0.0, 2.625) rectangle (1.5, 4.125)
                node[pos = 0.5, text = white, align = center] {\small Logik};
        \draw [fill = HKS41!40]
                (2.625, 2.625) rectangle (4.125, 4.125)
                node[pos = 0.5, text = white, align = center] {\small Speicher};
        \draw [fill = HKS41!80]
                (5.25, 2.625) rectangle (6.75, 4.125)
                node[pos = 0.5, text = white, align = center] {\small Logik};
        \draw [fill = HKS41]
                (7.875, 2.625) rectangle (9.375, 4.125)
                node[pos = 0.5, text = white, align = center] {\small Multipli- \\ zierer};
        \draw [fill = HKS41!60]
                (10.5, 2.625) rectangle (11.25, 4.125)
                node[pos = 0.5, text = white, align = center] {\small E/A};

        % Reihe 3
        \draw [fill = HKS41!60]
                (-1.875, 5.25) rectangle (-1.125, 6.75)
                node[pos = 0.5, text = white, align = center] {\small E/A};
        \draw [fill = HKS41!80]
                (0.0, 5.25) rectangle (1.5, 6.75)
                node[pos = 0.5, text = white, align = center] {\small Logik};
        \draw [fill = HKS41!40]
                (2.625, 5.25) rectangle (4.125, 6.75)
                node[pos = 0.5, text = white, align = center] {\small Speicher};
        \draw [fill = HKS41!80]
                (5.25, 5.25) rectangle (6.75, 6.75)
                node[pos = 0.5, text = white, align = center] {\small Logik};
        \draw [fill = HKS41]
                (7.875, 5.25) rectangle (9.375, 6.75)
                node[pos = 0.5, text = white, align = center] {\small Multipli- \\ zierer};
        \draw [fill = HKS41!60]
                (10.5, 5.25) rectangle (11.25, 6.75)
                node[pos = 0.5, text = white, align = center] {\small E/A};

        % Reihe 3
        \draw [fill = HKS41!60]
                (-1.875, 7.875) rectangle (-1.125, 9.375)
                node[pos = 0.5, text = white, align = center] {\small E/A};
        \draw [fill = HKS41!80]
                (0.0, 7.875) rectangle (1.5, 9.375)
                node[pos = 0.5, text = white, align = center] {\small Logik};
        \draw [fill = HKS41!40]
                (2.625, 7.875) rectangle (4.125, 9.375)
                node[pos = 0.5, text = white, align = center] {\small Speicher};
        \draw [fill = HKS41!80]
                (5.25, 7.875) rectangle (6.75, 9.375)
                node[pos = 0.5, text = white, align = center] {\small Logik};
        \draw [fill = HKS41]
                (7.875, 7.875) rectangle (9.375, 9.375)
                node[pos = 0.5, text = white, align = center] {\small Multipli- \\ zierer};
        \draw [fill = HKS41!60]
                (10.5, 7.875) rectangle (11.25, 9.375)
                node[pos = 0.5, text = white, align = center] {\small E/A};

        % obere E/A-Reihe
        \draw [fill = HKS41!60]
                (0.0, 10.5) rectangle (1.5, 11.25)
                node[pos = 0.5, text = white, align = center] {\small E/A};
        \draw [fill = HKS41!60]
                (2.625, 10.5) rectangle (4.125, 11.25)
                node[pos = 0.5, text = white, align = center] {\small E/A};
        \draw [fill = HKS41!60]
                (5.25, 10.5) rectangle (6.75, 11.25)
                node[pos = 0.5, text = white, align = center] {\small E/A};
        \draw [fill = HKS41!60]
                (7.875, 10.5) rectangle (9.375, 11.25)
                node[pos = 0.5, text = white, align = center] {\small E/A};

        % Verbindungen - Spalte 1
        \draw [color = HKS92!90, line width = 5mm]
                (0.75, -1.125) -- (0.75, 0.0);
        \draw [color = HKS92!90, line width = 5mm]
                (0.75, 1.5) -- (0.75, 2.625);
        \draw [color = HKS92!90, line width = 5mm]
                (0.75, 4.125) -- (0.75, 5.25);
        \draw [color = HKS92!90, line width = 5mm]
                (0.75, 6.75) -- (0.75, 7.875);
        \draw [color = HKS92!90, line width = 5mm]
                (0.75, 9.375) -- (0.75, 10.5);

        % Verbindungen - Spalte 2
        \draw [color = HKS92!90, line width = 5mm]
                (3.375, -1.125) -- (3.375, 0.0);
        \draw [color = HKS92!90, line width = 5mm]
                (3.375, 1.5) -- (3.375, 2.625);
        \draw [color = HKS92!90, line width = 5mm]
                (3.375, 4.125) -- (3.375, 5.25);
        \draw [color = HKS92!90, line width = 5mm]
                (3.375, 6.75) -- (3.375, 7.875);
        \draw [color = HKS92!90, line width = 5mm]
                (3.375, 9.375) -- (3.375, 10.5);

        % Verbindungen - Spalte 3
        \draw [color = HKS92!90, line width = 5mm]
                (6.0, -1.125) -- (6.0, 0.0);
        \draw [color = HKS92!90, line width = 5mm]
                (6.0, 1.5) -- (6.0, 2.625);
        \draw [color = HKS92!90, line width = 5mm]
                (6.0, 4.125) -- (6.0, 5.25);
        \draw [color = HKS92!90, line width = 5mm]
                (6.0, 6.75) -- (6.0, 7.875);
        \draw [color = HKS92!90, line width = 5mm]
                (6.0, 9.375) -- (6.0, 10.5);

        % Verbindungen - Spalte 4
        \draw [color = HKS92!90, line width = 5mm]
                (8.625, -1.125) -- (8.625, 0.0);
        \draw [color = HKS92!90, line width = 5mm]
                (8.625, 1.5) -- (8.625, 2.625);
        \draw [color = HKS92!90, line width = 5mm]
                (8.625, 4.125) -- (8.625, 5.25);
        \draw [color = HKS92!90, line width = 5mm]
                (8.625, 6.75) -- (8.625, 7.875);
        \draw [color = HKS92!90, line width = 5mm]
                (8.625, 9.375) -- (8.625, 10.5);

        % Verbindungen - Reihe 1
        \draw [color = HKS92!90, line width = 5mm]
                (-1.125, 0.75) -- (0.0, 0.75);
        \draw [color = HKS92!90, line width = 5mm]
                (1.5, 0.75) -- (2.625, 0.75);
        \draw [color = HKS92!90, line width = 5mm]
                (4.125, 0.75) -- (5.25, 0.75);
        \draw [color = HKS92!90, line width = 5mm]
                (6.75, 0.75) -- (7.875, 0.75);
        \draw [color = HKS92!90, line width = 5mm]
                (9.375, 0.75) -- (10.5, 0.75);

        % Verbindungen - Reihe 2
        \draw [color = HKS92!90, line width = 5mm]
                (-1.125, 3.375) -- (0.0, 3.375);
        \draw [color = HKS92!90, line width = 5mm]
                (1.5, 3.375) -- (2.625, 3.375);
        \draw [color = HKS92!90, line width = 5mm]
                (4.125, 3.375) -- (5.25, 3.375);
        \draw [color = HKS92!90, line width = 5mm]
                (6.75, 3.375) -- (7.875, 3.375);
        \draw [color = HKS92!90, line width = 5mm]
                (9.375, 3.375) -- (10.5, 3.375);

        % Verbindungen - Reihe 3
        \draw [color = HKS92!90, line width = 5mm]
                (-1.125, 6.0) -- (0.0, 6.0);
        \draw [color = HKS92!90, line width = 5mm]
                (1.5, 6.0) -- (2.625, 6.0);
        \draw [color = HKS92!90, line width = 5mm]
                (4.125, 6.0) -- (5.25, 6.0);
        \draw [color = HKS92!90, line width = 5mm]
                (6.75, 6.0) -- (7.875, 6.0);
        \draw [color = HKS92!90, line width = 5mm]
                (9.375, 6.0) -- (10.5, 6.0);

        % Verbindungen - Reihe 4
        \draw [color = HKS92!90, line width = 5mm]
                (-1.125, 8.625) -- (0.0, 8.625);
        \draw [color = HKS92!90, line width = 5mm]
                (1.5, 8.625) -- (2.625, 8.625);
        \draw [color = HKS92!90, line width = 5mm]
                (4.125, 8.625) -- (5.25, 8.625);
        \draw [color = HKS92!90, line width = 5mm]
                (6.75, 8.625) -- (7.875, 8.625);
        \draw [color = HKS92!90, line width = 5mm]
                (9.375, 8.625) -- (10.5, 8.625);

        % Verbindungen - Zwischenspalten
        \draw [color = HKS92!90, line width = 5mm]
                (-0.5625, -0.8125) -- (-0.5625, 10.1875);
        \draw [color = HKS92!90, line width = 5mm]
                (2.0625, -0.5625) -- (2.0625, 9.9375);
        \draw [color = HKS92!90, line width = 5mm]
                (4.6875, -0.5625) -- (4.6875, 9.9375);
        \draw [color = HKS92!90, line width = 5mm]
                (7.3125, -0.5625) -- (7.3125, 9.9375);
        \draw [color = HKS92!90, line width = 5mm]
                (9.9375, -0.8125) -- (9.9375, 10.1875);

        % Verbindungen - Zwischenzeilen
        \draw [color = HKS92!90, line width = 5mm]
                (-0.5625, -0.5625) -- (9.9375, -0.5625);
        \draw [color = HKS92!90, line width = 5mm]
                (-0.5625, 2.0625) -- (9.9375, 2.0625);
        \draw [color = HKS92!90, line width = 5mm]
                (-0.5625, 4.6875) -- (9.9375, 4.6875);
        \draw [color = HKS92!90, line width = 5mm]
                (-0.5625, 7.3125) -- (9.9375, 7.3125);
        \draw [color = HKS92!90, line width = 5mm]
                (-0.5625, 9.9375) -- (9.9375, 9.9375);
    \end{tikzpicture}
    \caption{abstrakter FPGA-Aufbau \cite[nach][10-14]{hawkins2010}}
    \label{fpga:definition:aufbau}
\end{figure}

\subsection{Aufbau moderner FPGAs}

Am Beispiel der Virtex-UltraScale+-Architektur der Firma Xilinxrs soll der
Aufbau eines modernen \gls{fpga} verdeutlicht werden. \gls{fpga}s dieser
Architektur bestehen aus sechs fundamentalen programmierbaren Elementen:
\begin{itemize}
    \item Konfigurierbare Logikblöcke (engl. \gls{clb}) bestehen aus acht
          Logikeinheiten, die man als \gls{lut} bezeichnet und zur
          Generierung von Logikfunktionen verwendet werden können. Daneben sind
          in einem \gls{clb} Speicherelemente enthalten, die als Flipflop oder
          Latch verwendet werden können, sowie weitere Elemente wie Multiplexer
          oder Einheiten für den arithmetischen Übertrag.
          \cite[vgl.][6]{ultrascaleclb2017}
    \item Eingabe/Ausgabe-Blöcke (engl. \gls{iob}) werden zur Steuerung des
          Datenflusses zwischen den E/A-Pins und der internen Schaltkreise
          benutzt. Die UltraScale+-Architektur bietet verschiedene
          \gls{iob}-Typen, die z.B. verschiedene E/A-Standards oder uni- oder
          bidirektionale Kommunikation unterstützen. \cite[vgl. die
          ausführliche E/A"=Beschreibung in][Kapitel 1 und 2]{ultrascaleio2019}
    \item \glqq Block RAM\grqq\ kann bis zu \SI{36}{\kilo\bit} speichern. Dabei
          lässt sich ein Block bei Bedarf auch in zwei unabhängige RAMs mit
          jeweils \SI{18}{\kilo\bit} zerlegen. Zusätzlich sind in einem
          Taktschritt voneinander unabhängige Lese- und Schreibzugriffe möglich.
          Benachbarte Blöcke lassen sich darüber hinaus miteinander verbinden,
          um größere RAM-Bereiche zu generieren.
          \cite[vgl.][6]{ultrascalemem2019}
    \item UltraRAM-Blöcke können bis zu \SI{288}{\kilo\bit} speichern, sind im
          Vergleich mit Block RAM aber unflexibler, da Lese- und Schreibzugriffe
          nicht parallel in einem Taktschritt möglich sind. Wie beim Block RAM
          lassen sich auch beim UltraRAM mehrere Blöcke zusammenschalten, um
          einen größeren Speicher zu erzeugen.
          \cite[vgl.][92--94]{ultrascalemem2019}
    \item Digitale Signalprozessoren (engl. \gls{dsp}) sind Blöcke, die für die
          Ausführung fundamentaler mathematischer oder bitweiser Operationen der
          Signal-, Bild- und Videoverarbeitung besonders gut geeignet sind. Aus
          mehreren \gls{dsp}s lassen sich durch Verbindungen komplexere
          Funktionen generieren. \cite[vgl.][7--8]{ultrascaledsp2019}
    \item Blöcke für die Taktverwaltung (engl. \gls{cmt}) generieren den Takt
          für die restlichen Komponenten des \gls{fpga}. Sie sind ebenso dazu
          geeignet, Operationen auf einem von außen kommenden Takt
          durchzuführen, z.B. eine Phasenverschiebung oder eine Filterung.
          \cite[vgl.][35--40]{ultrascaleclock2018}
\end{itemize}
Daneben können auf Beschleunigern, die mit einem \gls{fpga} ausgerüstet sind,
noch weitere Komponenten hinzukommen. Ein Beispiel dafür ist der als DRAM
bezeichnete Speicher, der mehrere \si{\gibi\byte} umfassen kann. Im Vergleich
zu Block RAM und UltraRAM weist dieser Speichertyp aber deutlich geringere
Speicherbandbreiten auf. Auf dem Beschleuniger \textit{Alveo U200}, der mit
einem UltraScale+-\gls{fpga} mit der Modellbezeichnung \textit{XCU200}
ausgestattet ist, finden sich beispielsweise vier DDR4-RAM-Module mit einer
Bandbreite von \SI{77}{\gibi\byte\per\second}.
\cites[vgl.][3]{alveo2019}[2]{alveobrief2018}

Ein XCU200-\gls{fpga} verteilt die oben genannten Elemente auf drei Abschnitte,
die als \gls{slr} bezeichnet werden. Gemeinsam bilden die \gls{slr}s drei
dynamische Regionen sowie eine statische Region, die alle mit dem DRAM des
Beschleunigers verbunden sind (siehe Abbildung~\ref{fpga:aufbau:alveoslr}). Die
dynamischen Regionen lassen sich vom Benutzer konfigurieren, während die
statische Region der Laufzeitumgebung des \gls{fpga}-Host-Systems vorbehalten
ist \cite[vgl.][4]{alveo2019}. Die Ressourcen verteilen sich in
unterschiedlicher Anzahl auf die \gls{slr}s, wie 
Tabelle~\ref{fpga:aufbau:ressourcen} zeigt.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        % unten
        \draw (0.0, 0.0) rectangle (7.5, 2.5)
            node [pos = 0.5] {dynamische Region}
            node [pos = 0.1] {SLR0};

        % Mitte
        \draw [draw = none] (0.0, 2.5) rectangle (7.5, 5)
            node [pos = 0.1] {SLR1};
        \draw (0.0, 2.5) rectangle (3.75, 5)
            node [pos = 0.5] {dynamische Region};
        \draw [fill = HKS92!90] (3.75, 2.5) rectangle (7.5, 5)
            node [pos = 0.5, color = white] {statische Region};

        % oben
        \draw (0.0, 5) rectangle (7.5, 7.5)
            node [pos = 0.5] {dynamische Region}
            node [pos = 0.1] {SLR2};
    \end{tikzpicture}
    \caption{Aufbau eines XCU200-FPGAs \cite[nach][5]{alveo2019}}
    \label{fpga:aufbau:alveoslr}
\end{figure}

\begin{table}[htb]
    \centering
    \begin{tabulary}{\textwidth}{@{}LCCCC@{}}
        \toprule
        \textbf{Ressource} & \textbf{Gesamt} & \textbf{SLR0} & \textbf{SLR1}
            & \textbf{SLR2} \tabularnewline\midrule
        CLB & \num{111500} & \num{45625} & \num{20250} &
            \num{45625}\tabularnewline
        Block RAM (\SI{36}{\kibi\byte}) & \num{1766} & \num{695} & 
            \num{376} & \num{695}\tabularnewline
        UltraRAM (\SI{288}{\kibi\byte}) & \num{800} & \num{320} &
            \num{160} & \num{320}\tabularnewline
        DSP & \num{5867} & \num{2275} & \num{1317} &
            \num{2275}\tabularnewline\bottomrule
    \end{tabulary}
    \caption{Ressourcen der dynamischen Regionen eines XCU200-FPGAs
             \cite[siehe][5]{alveo2019}}
    \label{fpga:aufbau:ressourcen}
\end{table}

Innerhalb der \gls{slr}s sind die Ressourcen spaltenweise verteilt (wie in
Abbildung~\ref{fpga:aufbau:spalten} dargestellt). Zusätzlich werden die Spalten
in vertikale Abschnitte von 60 \gls{clb}s bzw. der äquivalenten Anzahl der
anderen Blocktypen unterteilt. Ein solcher Abschnitt bildet eine von Xilinx als
\textit{clock region} bezeichnete Struktur. Zusammengefasst ergibt sich
dadurch eine spaltenorientierte Gitterstruktur, wie sie in
Abbildung~\ref{fpga:aufbau:clockregions} zu sehen ist.
\cite[vgl.][22]{ultrascale2019}

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \draw [fill = HKS92!90] (0.0, 0.0) rectangle (1.0, 8.0)
            node [pos = 0.5, rotate = 90, color = white] {externe E/A};
        \draw (1.0, 0.0) rectangle (2.5, 8.0)
            node [pos = 0.5, rotate = 90] {CLB, DSP, Block RAM, UltraRAM};
        \draw [fill = HKS92!70] (2.5, 0.0) rectangle (3.5, 8.0)
            node [pos = 0.5, rotate = 90, color = white] {E/A, Takt, Speicherschnittstelle};
        \draw (3.5, 0.0) rectangle (5.0, 8.0)
            node [pos = 0.5, rotate = 90] {CLB, DSP, Block RAM, UltraRAM};
        \draw [fill = HKS92!70] (5.0, 0.0) rectangle (6.0, 8.0)
            node [pos = 0.5, rotate = 90, color = white] {E/A, Takt, Speicherschnittstelle};
        \draw (6.0, 0.0) rectangle (7.5, 8.0)
            node [pos = 0.5, rotate = 90] {CLB, DSP, Block RAM, UltraRAM};
        \draw [fill = HKS92!90] (7.5, 0.0) rectangle (8.5, 8.0)
            node [pos = 0.5, rotate = 90, color = white] {externe E/A};
    \end{tikzpicture}
    \caption{spaltenweise Verteilung der FPGA-Ressourcen
             \cite[nach][22]{ultrascale2019}}
    \label{fpga:aufbau:spalten}
\end{figure}

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        % Spalten
        \draw [fill = HKS92!90] (0.0, 0.0) rectangle (1.0, 8.0);
        \draw (1.0, 0.0) rectangle (2.5, 8.0);
        \draw [fill = HKS92!70] (2.5, 0.0) rectangle (3.5, 8.0);
        \draw (3.5, 0.0) rectangle (5.0, 8.0);
        \draw [fill = HKS92!70] (5.0, 0.0) rectangle (6.0, 8.0);
        \draw (6.0, 0.0) rectangle (7.5, 8.0);
        \draw [fill = HKS92!90] (7.5, 0.0) rectangle (8.5, 8.0);

        % Querlinien
        \draw (0.0, 2.0) -- (8.5, 2.0);
        \draw (0.0, 4.0) -- (8.5, 4.0);
        \draw (0.0, 6.0) -- (8.5, 6.0);

        % Klammer
        \draw [decorate, decoration = {brace, amplitude = 2.5mm}, xshift = -2mm]
            (0.0, 6.0) -- (0.0, 8.0)
            node [pos = 0.5, xshift = -11mm, align = center] {60 CLBs};
    \end{tikzpicture}
    \caption{Aufteilung der FPGA-Ressourcen auf \textit{clock regions}
             \cite[nach][22]{ultrascale2019}}
    \label{fpga:aufbau:clockregions}
\end{figure}

\subsection{Anwendungsfälle}

Gegenüber ASICs bieten \gls{fpga}s einige Vorteile. Da sich Schaltungen ohne
einen Produktionsprozess schneller in Hardware abbilden lassen, eignen sich
\gls{fpga}s für die Entwicklung neuer Schaltungen durch die Methode des
\textit{rapid prototyping} und damit für eine schnellere Markteinführung. Durch
die einfache Neuprogrammierung lassen sich Fehler außerdem während des
Entwicklungsprozesses sowie während des Lebenszyklus des Produkts deutlich
einfacher beheben, als dies bei ASICs der Fall wäre.
\cite[vgl.][10-1]{hawkins2010}

Dadurch eignen sich \gls{fpga}s sehr gut für den Einsatz als Schaltkreise, die
in kleiner bis mittlerer Menge produziert werden sollen, weil die finanzielle
Einstiegshürde deutlich geringer als bei ASICs ist. Umgekehrt sind ASICs bei
hohen Produktionsvolumen überlegen, da die Kosten pro Chip geringer sind.
\cite[vgl.][10-2]{hawkins2010}

In jüngerer Zeit wurden \gls{fpga}s auch außerhalb des klassischen
Schaltkreisentwurfs eingesetzt. So setzt die Firma Microsoft beispielsweise
\gls{fpga}s des Herstellers Intel für die Inferenz tiefer neuraler Netzwerke
\cite[vgl.][]{fowers2018, chung2018} sowie als besonders schnelle
Netzwerkkarten ein \cite[vgl.][]{firestone2018}.

\section{Entwicklungsprozess}

\subsection{Hardware-Beschreibungssprachen}

\subsection{High-Level-Synthese}

\section{Parallelität}
